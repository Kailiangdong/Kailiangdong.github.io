<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="frontend,book notes,javascript,">










<meta name="description" content="第一章 JavaScript简介文档对象模型（DOM) ,提供访问和操作网页内容的方法和接口浏览器对象模型（BOM), 提供与浏览器交互的方法和窗口,windows对象   ：弹出浏览器，缩放浏览器，提供分辨率，提供cookies支持 第二章 JavaScript运用在html中XHTML中tag可以不用封口，但是html很严格需要封口。 假如把script 的tag放在head里面，浏览器要加载">
<meta name="keywords" content="frontend,book notes,javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="《javascript高级程序设计》 复习笔记">
<meta property="og:url" content="http://yoursite.com/2019/05/06/《javascript高级程序设计》-复习笔记/index.html">
<meta property="og:site_name" content="KailiangDong&#39;s Blog">
<meta property="og:description" content="第一章 JavaScript简介文档对象模型（DOM) ,提供访问和操作网页内容的方法和接口浏览器对象模型（BOM), 提供与浏览器交互的方法和窗口,windows对象   ：弹出浏览器，缩放浏览器，提供分辨率，提供cookies支持 第二章 JavaScript运用在html中XHTML中tag可以不用封口，但是html很严格需要封口。 假如把script 的tag放在head里面，浏览器要加载">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190509174122251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI4NTcxMg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190510190335194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI4NTcxMg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190510195837652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI4NTcxMg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190512041711248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI4NTcxMg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190516021703278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI4NTcxMg==,size_16,color_FFFFFF,t_70">
<meta property="og:updated_time" content="2019-06-25T15:11:35.143Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《javascript高级程序设计》 复习笔记">
<meta name="twitter:description" content="第一章 JavaScript简介文档对象模型（DOM) ,提供访问和操作网页内容的方法和接口浏览器对象模型（BOM), 提供与浏览器交互的方法和窗口,windows对象   ：弹出浏览器，缩放浏览器，提供分辨率，提供cookies支持 第二章 JavaScript运用在html中XHTML中tag可以不用封口，但是html很严格需要封口。 假如把script 的tag放在head里面，浏览器要加载">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190509174122251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI4NTcxMg==,size_16,color_FFFFFF,t_70">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/06/《javascript高级程序设计》-复习笔记/">





  <title>《javascript高级程序设计》 复习笔记 | KailiangDong's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KailiangDong's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Think Over then do it.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/06/《javascript高级程序设计》-复习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kailiang Dong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KailiangDong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《javascript高级程序设计》 复习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-06T19:01:55+02:00">
                2019-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/study/" itemprop="url" rel="index">
                    <span itemprop="name">study</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第一章-JavaScript简介"><a href="#第一章-JavaScript简介" class="headerlink" title="第一章 JavaScript简介"></a>第一章 JavaScript简介</h1><p>文档对象模型（DOM) ,提供访问和操作网页内容的方法和接口<br>浏览器对象模型（BOM), 提供与浏览器交互的方法和窗口,windows对象<br>   ：弹出浏览器，缩放浏览器，提供分辨率，提供cookies支持</p>
<h1 id="第二章-JavaScript运用在html中"><a href="#第二章-JavaScript运用在html中" class="headerlink" title="第二章 JavaScript运用在html中"></a>第二章 JavaScript运用在html中</h1><p>XHTML中tag可以不用封口，但是html很严格需要封口。</p>
<p>假如把script 的tag放在head里面，浏览器要加载好js才能呈现页面，就很慢，所以我们一般放在body前面。</p>
<p>script里面延迟属性， 加一个属性defer = “defer”。告诉他脚本执行时不会影响页面的构造。</p>
<h1 id="第三章-基本概念"><a href="#第三章-基本概念" class="headerlink" title="第三章 基本概念"></a>第三章 基本概念</h1><p>变量名 test和Test是两个不同变量名<br>JavaScript严格模式”use strict”<br>良好的代码风格。加上分号和代码块</p>
<p>定义一个var变量，他在局部变量使用后马上销毁<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> message = <span class="string">"hi"</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure></p>
<p>但是如果不加var，就会变成全局变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	message = <span class="string">"hi"</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JavaScript五种简单的类型， Undefined, Null, Boolean, Number 和 String.<br>复杂数据类型 Object。<br>使用typeof鉴别类型，这是一个操作符不是函数<br>typeof null 返回 object,特殊值null被认为是一个空对象的引用。</p>
<h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>未初始化变量就是undefined，不用特意把一个变量设置为undefined<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对未声明的变量只能用typeof</span></span><br><span class="line"><span class="comment">// var tmp</span></span><br><span class="line">alert(tmp);  <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">typeof</span> tmp;<span class="comment">//得到答案，”undefined"</span></span><br><span class="line">### null</span><br><span class="line"><span class="literal">null</span>就是一个空对象指针</span><br><span class="line">对于你不知道初始化什么值得时候，赋予它<span class="literal">null</span>，这样你下次也好判定是不是<span class="literal">null</span></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">//事实上这个返回true，因为undefined的值派生自null值</span></span><br><span class="line"><span class="string">alert(null == undefined);</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><p>要将一个值转化为其对应的boolean的值，可以调用转型函数Boolean();<br>string: 非空字符串转化为true， 空字符串false;<br>number: 任何非零数字值转化为true，0和nan转化为false;</p>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">070</span> <span class="comment">//八进制的56</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">0xA</span> <span class="comment">//十六进制的10</span></span><br></pre></td></tr></table></figure>
<p><strong>浮点数不准，慎用</strong>0.1+0.3不等于0.4</p>
<p>NaN 非数值，解决的问题，表示本来要返回数值的操作数未返回数值的情况。<br>值得注意的是，NaN和任何值都不相等，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="literal">NaN</span> == <span class="literal">NaN</span>);</span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>));<span class="comment">//true</span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="number">10</span>));  <span class="comment">//false</span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="string">"10"</span>)); <span class="comment">//false</span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="string">"blue"</span>)); <span class="comment">//true</span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="literal">true</span>));  <span class="comment">//false ,可以被转化为数值1</span></span><br><span class="line"><span class="comment">//任何不是数值的值被转化为数值，实在不行返回false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><h4 id="Number-1"><a href="#Number-1" class="headerlink" title="Number()"></a>Number()</h4><p>把任何数据类型转换成数值,字符串空的转化为0,不空而且不是数字的话为NaN<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) = <span class="literal">NaN</span>;</span><br><span class="line"><span class="built_in">Number</span>(<span class="string">"asdasd"</span>) =<span class="literal">NaN</span>;</span><br><span class="line"><span class="built_in">Number</span>(<span class="string">""</span>) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>重点看p30页</p>
<h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h4><p>parseInt只认到数字结束<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">"1234blue"</span>);  <span class="comment">//1234</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">""</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"0xA"</span>); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">2</span>);   <span class="comment">//按照二进制解析</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">8</span>);  <span class="comment">//按照八进制解析</span></span><br></pre></td></tr></table></figure></p>
<h4 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="number">22.34</span><span class="number">.5</span>); <span class="comment">//22.34</span></span><br></pre></td></tr></table></figure>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>toString() 方法，null和undefined没有这个方法<br>num.toString(8) //把数字转成八进制<br>判定一个数是不是string可以用String()<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="literal">null</span>) = <span class="string">"null"</span>;</span><br><span class="line"><span class="keyword">var</span> tmp;</span><br><span class="line"><span class="built_in">String</span>(tmp) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//创建新对象</span></span><br></pre></td></tr></table></figure>
<p>在ECMASript中，Object类型是它的实例的基础。Object类型所具有的任何属性和方法也存在更具体的对象中<br>Object每个实例都具有下列属性和方法<br>1，constructor:保存着用于创建当前对象的函数。<br>2，hasOwnProperty(propertyName):用于检查给定的属性在当前实例中是否存在。<br>3， isPrototypeOf(object) 用于检查传入的对象是否是当前对象的原型。<br>4， toString()返回的对象用字符串表示<br>5,    valueOf() 返回的对象的字符串，数值或布尔值来表示。<br>6， propertyIsEnumerable(propertyName) 用于检查给定的属性是否能够使用for-in语句</p>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>++n 在这个n被真正用上之前就+1了<br>n++  在这个n被真正用上之后才+1了<br>几种有趣的情况<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"15"</span>++;  <span class="comment">// 16</span></span><br><span class="line"><span class="string">"asda"</span>++ <span class="comment">//NaN</span></span><br><span class="line"><span class="literal">false</span>++ <span class="comment">//1</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">	valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">o--; <span class="comment">//值变成-2,原因先调用对象的valueOf()方法，如果结果是NaN,调用toString()后再应用前述规则</span></span><br></pre></td></tr></table></figure></p>
<h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><p>先将64位值转换成32位的整数，然后执行操作，最后将结果转换回64位。<br>负数二进制补码详情看 p40;<br>位非 ~， 变成负数还要减1；<br>位and , &amp;<br>位或， |<br>位异或， XOR<br>左移 &lt;&lt;<br>右移 &gt;&gt;   第一位符号位不变<br>无符号右移 &gt;&gt;&gt; 和&gt;&gt;在负数情况下不同</p>
<h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3><p>逻辑非<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(!<span class="string">"blue"</span>); <span class="comment">//false</span></span><br><span class="line">alert(!<span class="literal">NaN</span>); <span class="comment">//true</span></span><br><span class="line">alert(!<span class="string">""</span>); <span class="comment">//true</span></span><br><span class="line">alert(!<span class="number">12345</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p>逻辑与<br>第一个操作数是null,NaN,undefined分别返回null, NaN,undefined.<br>属于短路操作，第一个操作如果能决定结果false，不会对第二个操作数求值。<br>逻辑或<br>第一个操作数是null,NaN,undefined分别返回null, NaN,undefined.<br>属于短路操作，第一个操作如果能决定结果true，不会对第二个操作数求值。<br>利用这一点避免变量null或者undefined值<br>var myObject = preferredObject || backupObject;</p>
<h3 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h3><p>NaN与其他乘， 结果是NaN<br>Infinity与0相乘，结果是NaN</p>
<h3 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h3><p>一个操作数结果是NaN,则结果是NaN<br>一个字符串和数字相加，数字串变成字符串串联<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>+<span class="number">10</span>); <span class="comment">//10;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>+<span class="number">10</span>);<span class="comment">//NaN</span></span><br></pre></td></tr></table></figure></p>
<h3 id="减性操作符"><a href="#减性操作符" class="headerlink" title="减性操作符"></a>减性操作符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result6 = <span class="number">5</span> - <span class="literal">null</span>;<span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>字符串比较，比较编码大小<br>一个值是布尔值，先转化为数值。<br><figure class="highlight plain"><figcaption><span>//false```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">因为比较第一个编码</span><br><span class="line"></span><br><span class="line">### 相等操作符</span><br><span class="line">一个操作数是布尔值，将其转换为数值</span><br><span class="line">null 和undefined是相等的</span><br></pre></td></tr></table></figure></p>
<p>NaN == NaN  //false<br>NaN ！=NaN //true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">全等 ===  //两个操作数未经转换就相等的情况下返回true</span><br><span class="line"> 不全等！== </span><br><span class="line"> </span><br><span class="line">###  条件操作符</span><br><span class="line">```javascript</span><br><span class="line">var max = (num1 &gt; num2) ?num1:num2;</span><br></pre></td></tr></table></figure></p>
<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i&lt; count;i++)[</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有var的话，我在外面也可以访问到。</span></span><br></pre></td></tr></table></figure>
<h3 id="for-in语句"><a href="#for-in语句" class="headerlink" title="for-in语句"></a>for-in语句</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (property <span class="keyword">in</span> expression) statement <span class="comment">//要防止里里面有null或者undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><p>break会退出循环，从后面继续执行<br>continue跳出此段循环，从循环顶重新开始</p>
<h3 id="label-看p59页"><a href="#label-看p59页" class="headerlink" title="label 看p59页"></a>label 看p59页</h3><h3 id="with语句-不太用了"><a href="#with语句-不太用了" class="headerlink" title="with语句 不太用了"></a>with语句 不太用了</h3><p>###switch语句</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>1， return之后语句没用<br>2， 可以有多个return<br>3,  return; 代表return undefined<br>4，可以通过argument[i]调用参数，显式参数可以不写，可以用argument.length调用。<br>可以用argument[1]改写第二个参数，假如argument[1]没有指定他的值也是undefined.</p>
<h3 id="没有重载d"><a href="#没有重载d" class="headerlink" title="没有重载d"></a>没有重载d</h3><p>两个函数重点只看第二个</p>
<h1 id="变量，作用域和内存问题"><a href="#变量，作用域和内存问题" class="headerlink" title="变量，作用域和内存问题"></a>变量，作用域和内存问题</h1><p>基本类型是简单数据段，就是undefined, null, string ,number, boolean<br>引用类型是指那些可能由多个值构成的对象：object；</p>
<p>复制基本类型：从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本。<br>引用类型复制： 复制的值的副本是一个指针， 而这个值指向存储在堆中的一个对象，保存在堆内存中。</p>
<p>p70 -71 传递参数<br><a href="https://www.zhihu.com/question/27114726" target="_blank" rel="noopener">https://www.zhihu.com/question/27114726</a><br>传参都是传递值而不是传递引用。 对于object传递的其实也是引用的地址。很经典的例子如下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  value:<span class="string">'111'</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  value:<span class="string">'222'</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeStuff</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.value = <span class="string">'333'</span>;</span><br><span class="line">  obj = obj2;</span><br><span class="line">  <span class="keyword">return</span> obj.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = changeStuff(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(foo);<span class="comment">// '222' 参数obj指向了新的对象obj2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.value);<span class="comment">//'333'</span></span><br><span class="line"></span><br><span class="line">作者：苏墨橘</span><br><span class="line">链接：https:<span class="comment">//www.zhihu.com/question/27114726/answer/35481766</span></span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></p>
<p>确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以用instanceof操作符。<br>所有引用类型的值都是Object的实例。function的typeof是function<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">amd</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">""</span>);</span><br><span class="line">&#125; <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">typeof</span> amd  <span class="comment">//"function"</span></span><br></pre></td></tr></table></figure></p>
<p>变量对象都有一个作用域链，都是由内向外的。从内部环境到全局环境。内部环境可以用过作用域链访问所有外部环境，外部环境不能访问内部环境任何变量</p>
<h2 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h2><p>p75,with的解释<br><a href="https://lllt.iteye.com/blog/1246424" target="_blank" rel="noopener">https://lllt.iteye.com/blog/1246424</a><br>”由于with语句块中作用域的‘变量对象’是只读的，所以在他本层定义的标识符，不能存储到本层，而是存储到它的上一层作用域”</p>
<h2 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h2><p>js只有函数作用域，没有块级作用域。<br><strong>也就是说if语句和for语句中的变量能被外部访问。</strong><br>查询标识符， 函数先从内部局部变量开始查找变量，搜索到就停止，不然继续向全局搜索。</p>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><h3 id="标记清楚"><a href="#标记清楚" class="headerlink" title="标记清楚"></a>标记清楚</h3><p><a href="https://zhuanlan.zhihu.com/p/23992332" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23992332</a><br>那什么叫标记清除呢？JavaScript 中有个全局对象，浏览器中是 window。定期的，垃圾回收期将从这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象…对这些活着的对象进行标记，这是标记阶段。清除阶段就是清除那些没有被标记的对象。<br><strong>通俗的来讲，就是定时给所有内存中变量打上标记，然后现在在环境中，或使用中的变量去掉标记，最后删除还有标记的。</strong></p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>如果一个变量被引用了，就引用+1.假如引用它的变量被其他引用了，那么就-1.最后定时清楚引用为0的值。<br>但是有个问题就是有时候两个变量相互引用。<br>为了避免循环引用，一般用代码消除，element = null;这叫解除引用，也能避免用内存太多。</p>
<p>引用就是按照地址传值</p>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><p>创建object两种方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">//对象字面量表示</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name: <span class="string">"Nichloas"</span>,</span><br><span class="line">	age : <span class="number">29</span></span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure></p>
<p>访问对象属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="comment">//通常用第二种</span></span><br><span class="line">person.[<span class="string">"name"</span>];</span><br><span class="line">person.name;</span><br></pre></td></tr></table></figure></p>
<h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>数组可以动态调整，每一项可以保存任何类型的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var colors = new Array();</span><br><span class="line">var colors = [];</span><br><span class="line">var colors = new Array(20);</span><br><span class="line"></span><br><span class="line">colors.length = 2;//可以动态缩短数组长度，会移除最后一项。</span><br></pre></td></tr></table></figure></p>
<h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line"><span class="built_in">Array</span>.isArray(value);</span><br></pre></td></tr></table></figure>
<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">toLocaleString()</span><br><span class="line">toString()</span><br><span class="line">valueOf()</span><br><span class="line">join(“,&quot;); //把数组的字符串用”，“连接在一起。</span><br></pre></td></tr></table></figure>
<h3 id="栈方法与队列方法"><a href="#栈方法与队列方法" class="headerlink" title="栈方法与队列方法"></a>栈方法与队列方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈方法</span></span><br><span class="line">pop();</span><br><span class="line">push();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列方法</span></span><br><span class="line">shift(); <span class="comment">//移除数组中的第一个项并返回该项；</span></span><br><span class="line">push();<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">unshift();</span><br><span class="line">pop();</span><br></pre></td></tr></table></figure>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[].reverse;  <span class="comment">//翻转数组顺序</span></span><br><span class="line">[].sort(compare); <span class="comment">//进行排序，可以接受一个function来声明排序方法。</span></span><br><span class="line"><span class="comment">//比如</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> value2 - value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">concat();  <span class="comment">//将新数组和原来你的数组合并</span></span><br><span class="line">slice(); <span class="comment">//数组切片， 返回新数组，老数组不变</span></span><br><span class="line">splice(); <span class="comment">//很强大的方法，看p95，可以对数组进行删除，插入和替换</span></span><br></pre></td></tr></table></figure>
<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">indexOf() ; <span class="comment">//对一个数组查找对应的值， 找到返回位置，没找到返回-1；</span></span><br><span class="line">lastIndexOf(); <span class="comment">//从末尾开始往前找。必须严格相等。</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>1.every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则最终结果返回true；<br>2.some()：对数组中的每一项运行给定函数，如果该函数对任一项都返回true，则最终结果返回true；<br>3.filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组；<br>4.map()：对数组中的每一项运行给定函数，返回每次调用的结果组成的数组；<br>5.forEach：对数组中的每一项运行给定函数。这个方法没有返回值。<br>图片转自 <a href="https://www.cnblogs.com/shuiyi/p/5058524.html" target="_blank" rel="noopener">https://www.cnblogs.com/shuiyi/p/5058524.html</a><br>在这里插入图片描述<br><img src="https://img-blog.csdnimg.cn/20190509174122251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI4NTcxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">"May 25, 2004"</span>));</span><br><span class="line"><span class="comment">//parse帮助你，把人类语言表述的日期创建出来。</span></span><br><span class="line"><span class="keyword">var</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"May 25, 2004"</span>);</span><br><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="comment">//取得现在这个时间点的时间</span></span><br></pre></td></tr></table></figure>
<h3 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toLocaleString() ; <span class="comment">//返回当地时间，时间用am，pm表示。</span></span><br><span class="line">toString();</span><br></pre></td></tr></table></figure>
<p>还有一些格式化方法<br>请看p101</p>
<h2 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h2><p>i    执行对大小写不敏感的匹配。<br>g    执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。<br>m    执行多行匹配。<br>两种方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/[bc]at/i</span> ; </span><br><span class="line"><span class="comment">//构造函数创建</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"[bc]at"</span>,<span class="string">"i"</span>);</span><br><span class="line"><span class="comment">//使用构造函数，每次都是一个新的实例</span></span><br></pre></td></tr></table></figure></p>
<h3 id="RegExp实例属性"><a href="#RegExp实例属性" class="headerlink" title="RegExp实例属性"></a>RegExp实例属性</h3><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>exec() 专门为捕获组设计的<br>var matches = pattern.exec(text);<br>捕获组了解一下 p106</p>
<p>pattern.text()   //接受一个字符串参数，匹配返回true，不匹配返回false</p>
<h3 id="RegExp构造函数属性"><a href="#RegExp构造函数属性" class="headerlink" title="RegExp构造函数属性"></a>RegExp构造函数属性</h3><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>每个函数都是function类型的实例，函数名实际是指向函数对象的指针。<br>创造函数两种<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种创造函数的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum  = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1+num2"</span>);</span><br><span class="line"><span class="comment">//函数是对象，函数名是指针，函数名仅仅是指向函数的指针。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码开始执行之前，解析器通过一个名为函数声明提升的过程， 读取并将函数声明添加到执行环境</span></span><br><span class="line"><span class="comment">//函数表达式不能提前</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function callSomeFunction(someFunction ,someArgument)&#123;</span><br><span class="line">	return someFunction(someArgument);</span><br><span class="line">&#125;</span><br><span class="line">可以根据属性来比较</span><br><span class="line">object[propertyName];</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcName</span>(<span class="params">someFunc, someParam</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> someFunc(someParam)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = funcName(sum, <span class="number">5</span>);</span><br><span class="line">alert(result);  <span class="comment">//=&gt;8</span></span><br></pre></td></tr></table></figure>
<h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><p>为了解耦，在函数内部，特别是递归函数，用arguments.callee代替函数名</p>
<p>另一个特殊对象是this，在全局的this就是windows，在函数内部调用就是函数的执行对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>:<span class="string">"blue"</span> &#125;;</span><br><span class="line">o.saycolor() ; <span class="comment">//blue。绑定的是o</span></span><br></pre></td></tr></table></figure></p>
<p>对于引用类型来说，prototype是保存他们所有实例方法的真正所在。tostring()和valueOf()等方法就是在prototype下面。</p>
<h3 id="apply-和call"><a href="#apply-和call" class="headerlink" title="apply()和call()"></a>apply()和call()</h3><p>每个函数都有两个非继承的方法，这两个方法用途都是在特定的作用域中调用函数。<br>最大的用处就是能够扩充函数赖以运行的作用域<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span>  o = &#123; <span class="attr">color</span> : <span class="string">"blue"</span> &#125;；</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saycolor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">saycolor();</span><br><span class="line"></span><br><span class="line">saycolor.call(<span class="keyword">this</span>); <span class="comment">//red</span></span><br><span class="line">saycolor.call(o);  <span class="comment">//red</span></span><br><span class="line">saycolor.call(windows); <span class="comment">//blue</span></span><br></pre></td></tr></table></figure></p>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this值会绑定到传到bind()函数的值</span></span><br><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span>  o = &#123; <span class="attr">color</span> : <span class="string">"blue"</span> &#125;；</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saycolor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objectSaycolor = saycolor.bind(o);</span><br><span class="line">objectSaycolor();</span><br></pre></td></tr></table></figure>
<h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><p>Boolean,Number, String()<br>基本包装类型就是帮你弄了个对象，提供了你一些方法<br>自动创建的基本包装类型，只存在于代码执行瞬间，然后立即被销毁<br>使用new调用基本包装类型的构造函数 (number)，与直接调用同名的转型函数是不一样的(object);<br>每个包装类型都映射到同名的基本类型</p>
<h4 id="number类型"><a href="#number类型" class="headerlink" title="number类型"></a>number类型</h4><p>方法<br>num.toFixed(2);<br>num.toExponential(1);</p>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>String类型每个实例都有一个length属性<br>字符方法： charAt(1）; charCodeAt(1), stringvalue[1]</p>
<h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p>stringvalue.concat();<br>三种字符串 的方法<br>slice(), substr(), substring();<br>字符串位置方法：<br>indexOf(“o”);<br>lastIndexOf(“o”)</p>
<p>trim()方法<br>//创建一个字符串的脚本，删除前置以及后缀的空格。<br>字符串大小转换方法 toLowerCase(), toLocaleLowerCase(), toUpperCase(), toLocaleUpperCase();</p>
<p>match()<br>//字符串匹配方法。<br>search()<br>//返回字符串第一个匹配项的索引，没有找到匹配项，返回-1<br>replace();<br>//替换,<strong>捕获组看一看</strong> p128</p>
<p>localeCompare()方法<br>fromCharCode()方法</p>
<h3 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h3><p>不属于任何对象的属性和方法，最终就是它的属性和方法<br>所有在全局中定义的属性和方法，最终都是他的属性和方法。<br>encodeURI();<br>encodeURIComponent();</p>
<p>eval() 方法<br>通过eval()执行的 代码被认为是包含该次调用的执行环境之一。</p>
<h3 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h3><p>Math()方法<br>min()或者max()<br>Math.ceil() 执行向上舍入, Math.floor() 执行向下舍入 , Math.round() 执行标准舍入<br>Math.random()方法</p>
<h1 id="第六章-面向对象的程序设计"><a href="#第六章-面向对象的程序设计" class="headerlink" title="第六章 面向对象的程序设计"></a>第六章 面向对象的程序设计</h1><h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>对象定义为： 无序属性的集合，其属性可以包含基本值，对象和函数<br>每个对象由一个引用类型创建的<br>创建object<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建对象实例</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br><span class="line">person.job = <span class="string">"Software engineer"</span>;</span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面量</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name:  <span class="string">"Nicholas"</span>,</span><br><span class="line">	age: <span class="number">29</span>,</span><br><span class="line">	job: <span class="string">"Software Engineeer"</span>,</span><br><span class="line">	sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><p>[[Configurable]]：表示能否通过delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值为true。<br>[[Enumerable]]：表示能否通过for-in 循环返回属性。默认值为true。<br>[[Writable]]：表示能否修改属性的值。默认值为true。<br>[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为undefined。<br>修改属性默认的特性，必须使用ECMAScript 5 的Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable 和value。设置其中的一或多个值，可以修改对应的特性值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;);</span><br><span class="line">alert(person.name); <span class="comment">//"Nicholas"</span></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line">alert(person.name); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>不包含数据值；它们包含一对儿getter 和setter 函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter 函数并传入新值.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写setter，和getter</span></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    _year: <span class="number">2004</span>,</span><br><span class="line">    edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(newValue)&#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition); <span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><p>Object.getOwnPropertyDescriptor()<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>);</span><br><span class="line">alert(descriptor.value); <span class="comment">//2004</span></span><br><span class="line">alert(descriptor.configurable); <span class="comment">//false</span></span><br><span class="line">alert(<span class="keyword">typeof</span> descriptor.get); <span class="comment">//"undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"year"</span>);</span><br><span class="line">alert(descriptor.value); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>object构造函数和字面量创造某个对象有个缺点，就是有很多重复的代码</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>
<p>虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>构造函数可用来创建特定类型的对象。像Object 和Array 这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure></p>
<p>Person()中的代码除了与createPerson()中相同的部分外，还存在以下不同之处：<br>没有显式地创建对象；<br>直接将属性和方法赋给了this 对象；<br>没有return 语句。<br>按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。<br>这两个对象都有一个constructor（构造函数）属性，该属性指向Person<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person1.constructor == Person); <span class="comment">//true</span></span><br><span class="line">alert(person2.constructor == Person); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>但是，提到检测对象类型，还是instanceof操作符要更可靠一些。我们在这个例子中创建的所有对象既是Object 的实例，同时也是Person的实例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line">alert(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></span><br><span class="line">alert(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line">alert(person2 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>创造自定义构造函数意味着它的实例标识为特定的类型</p>
<h4 id="将构造函数当作函数"><a href="#将构造函数当作函数" class="headerlink" title="将构造函数当作函数"></a>将构造函数当作函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当作构造函数使用</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">person.sayName(); <span class="comment">//"Nicholas"</span></span><br><span class="line"><span class="comment">// 作为普通函数调用</span></span><br><span class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>); <span class="comment">// 添加到window-&gt;全局变量</span></span><br><span class="line"><span class="comment">//普通函数调用时this对象指向global对象</span></span><br><span class="line"><span class="built_in">window</span>.sayName(); <span class="comment">//"Greg"</span></span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用，绑定</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">"Kristen"</span>, <span class="number">25</span>, <span class="string">"Nurse"</span>);</span><br><span class="line">o.sayName(); <span class="comment">//"Kristen"</span></span><br></pre></td></tr></table></figure>
<p>构造函数的问题<br><strong>就是每个对象里面function其实不是一个</strong><br>主要问题，就是每个方法都要在每个实例上重新创建一遍，即：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"alert(this.name)"</span>); <span class="comment">// 与声明函数在逻辑上是等价的</span></span><br><span class="line">alert(person1.sayName == person2.sayName); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p>因此，大可像下面这样，通过把函数定义转移到构造函数外部来解决这个问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure></p>
<p>新问题又来了：在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h3><p>我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">//"Nicholas"</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">//"Nicholas"</span></span><br><span class="line">alert(person1.sayName == person2.sayName); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://img-blog.csdnimg.cn/20190510190335194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI4NTcxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，<strong>所有原型对象都会自动获得一个constructor（构造函数）属性</strong>，这个属性包含一个指向prototype 属性所在函数的指针。就拿前面的例子来说，Person.prototype. constructor 指向Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。<br>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。</p>
<p>虽然在所有实现中都无法访问到[[Prototype]]，但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系。从本质上讲，如果[[Prototype]]指向调用isPrototypeOf()方法的对象（Person.prototype），那么这个方法就返回true<br>ECMAScript 5 增加了一个新方法，叫Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype); <span class="comment">//true</span></span><br><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1).name); <span class="comment">//"Nichola</span></span><br></pre></td></tr></table></figure></p>
<p>虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name = <span class="string">"Greg"</span>;</span><br><span class="line">alert(person1.name); <span class="comment">//"Greg"——来自实例</span></span><br><span class="line">alert(person2.name); <span class="comment">//"Nicholas"——来自原型</span></span><br><span class="line"></span><br><span class="line">使用<span class="keyword">delete</span> 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性</span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line">alert(person1.name); <span class="comment">//"Nicholas"——来自原型</span></span><br></pre></td></tr></table></figure></p>
<p>使用hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不要忘了它是从Object 继承来的）只在给定属性存在于对象实例中时，才会返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">//false</span></span><br><span class="line">person1.name = <span class="string">"Greg"</span>;</span><br><span class="line">alert(person1.name); <span class="comment">//"Greg"——来自实例</span></span><br><span class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">//true</span></span><br><span class="line">alert(person2.name); <span class="comment">//"Nicholas"——来自原型</span></span><br><span class="line">alert(person2.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line">alert(person1.name); <span class="comment">//"Nicholas"——来自原型</span></span><br></pre></td></tr></table></figure></p>
<h3 id="原型与in操作符"><a href="#原型与in操作符" class="headerlink" title="原型与in操作符"></a>原型与in操作符</h3><p>在单独使用时，in 操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。<br>同时使用hasOwnProperty()方法和in 操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中，如下所示<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>for-in循环，返回的是所有能够通过对象访问的，可枚举的属性</strong><br>要取得对象上所有可枚举的实例属性，可以使用的Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(Person.prototype);</span><br><span class="line">alert(keys); <span class="comment">//"name,age,job,sayName"</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.name = <span class="string">"Rob"</span>;</span><br><span class="line">p1.age = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">var</span> p1keys = <span class="built_in">Object</span>.keys(p1);</span><br><span class="line">alert(p1keys); <span class="comment">//"name,age" .只包含了实例属性</span></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果你想要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype);</span><br><span class="line">alert(keys); <span class="comment">//"constructor,name,age,job,sayName"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="更简单的语法，每次用prototype你烦不烦"><a href="#更简单的语法，每次用prototype你烦不烦" class="headerlink" title="更简单的语法，每次用prototype你烦不烦"></a>更简单的语法，每次用prototype你烦不烦</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name : <span class="string">"Nicholas"</span>,</span><br><span class="line">    age : <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">    sayName : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例外：constructor 属性不再指向Person 了。前面曾经介绍过，每创建一个函数，就会同时创建它的prototype 对象，这个对象也会自动获得constructor 属性。而我们在这里使用的语法，本质上完全重写了默认的prototype 对象，因此constructor 属性也就变成了新对象的constructor 属性（指向Object 构造函数），不再指向Person 函数。此时，尽管instanceof操作符还能返回正确的结果，但通过constructor 已经无法确定对象的类型了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">alert(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line">alert(friend <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></span><br><span class="line">alert(friend.constructor == Person); <span class="comment">//false</span></span><br><span class="line">alert(friend.constructor == <span class="built_in">Object</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h3><p>如果是重写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。请记住：实例中的指针仅指向原型，而不指向构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name : "Nicholas",</span><br><span class="line">    age : 29,</span><br><span class="line">    job : "Software Engineer",</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayName(); <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://img-blog.csdnimg.cn/20190510195837652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI4NTcxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h3><p>所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。在Array.prototype 中可以找到sort()方法，而在String.prototype 中可以找到substring()方法</p>
<h3 id="原型的问题"><a href="#原型的问题" class="headerlink" title="原型的问题"></a>原型的问题</h3><p>原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，对于包含引用类型值的属性来说，问题就比较突出了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name : "Nicholas",</span><br><span class="line">    age : 29,</span><br><span class="line">    job : "Software Engineer",</span><br><span class="line">    friends : ["Shelby", "Court"],</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line">alert(person1.friends); <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person2.friends); <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person1.friends === person2.friends); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="组合使用构造函数模式与原型模式"><a href="#组合使用构造函数模式与原型模式" class="headerlink" title="组合使用构造函数模式与原型模式"></a>组合使用构造函数模式与原型模式</h2><p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span> : Person,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line">alert(person1.friends); <span class="comment">//"Shelby,Count,Van"</span></span><br><span class="line">alert(person2.friends); <span class="comment">//"Shelby,Count"</span></span><br><span class="line">alert(person1.friends === person2.friends); <span class="comment">//false</span></span><br><span class="line">alert(person1.sayName === person2.sayName); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">　　<span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName()</span><br></pre></td></tr></table></figure>
<p>通过if来判断，不能直接用function，否则会new function的实例。</p>
<h2 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h2><p>在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName(); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure></p>
<p>除了使用new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个return 语句，可以重写调用构造函数时返回的值。<br><strong>不要使用这种模式</strong></p>
<h2 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h2><p>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this 的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this 和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用this；二是不使用new 操作符调用构造函数。按照稳妥构造函数的要求，可以将前面的Person 构造函数重写如下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//创建要返回的对象</span></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">//可以在这里定义私有变量和函数</span></span><br><span class="line">    <span class="comment">//添加方法</span></span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回对象</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;·</span><br></pre></td></tr></table></figure></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><strong>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</strong><br>那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承了SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.getSuperValue()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>以上代码定义了两个类型：SuperType 和SubType。每个类型分别有一个属性和一个方法。它们的主要区别是SubType 继承了SuperType，而继承是通过创建SuperType 的实例，并将该实例赋给SubType.prototype 实现的。实现的本质是重写原型对象，代之以一个新类型的实例。<br><img src="https://img-blog.csdnimg.cn/20190512041711248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI4NTcxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>instance 指向SubType的原型， SubType 的原型又指向SuperType 的原型。getSuperValue() 方法仍然还在SuperType.prototype 中，但property 则位于SubType.prototype 中。这是因为property 是一个实例属性，而getSuperValue()则是一个原型方法。既然SubType.prototype 现在是SuperType的实例，那么property 当然就位于该实例中了。</p>
<p>所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。<br>一句话，SubType 继承了SuperType，而SuperType 继承了Object。当调用instance.toString()时，实际上调用的是保存在Object.prototype 中的那个方法。</p>
<h3 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SuperType); <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SubType); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>第二种方式是使用isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此isPrototypeOf()方法也会返回true<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></span><br><span class="line">alert(SuperType.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></span><br><span class="line">alert(SubType.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="谨慎地定义方法"><a href="#谨慎地定义方法" class="headerlink" title="谨慎地定义方法"></a>谨慎地定义方法</h3><p>子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。</p>
<p>还有一点需要提醒读者，即在通过原型链实现继承时，<strong>不能使用对象字面量创建原型方法</strong>。因为这样做就会重写原型链<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承了SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用字面量添加新方法，会导致上一行代码无效</span></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">    getSubValue : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">    &#125;,</span><br><span class="line">    someOtherMethod : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h3><p>最主要的问题来自包含引用类型值的原型。想必大家还记得，我们前面介绍过包含引用类型值的原型属性会被所有实例共享；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line"></span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green,black"</span></span><br></pre></td></tr></table></figure></p>
<p>原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。</p>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>子类型构造函数的内部调用超类型构造函数。<br>函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在（将来）新创建的对象上执行构造函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承了SuperType</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br></pre></td></tr></table></figure></p>
<p>可以从子类型构造函数中向超类型构造函数传递参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承了SuperType，同时还传递了参数</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line">    <span class="comment">//实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.name); <span class="comment">//"Nicholas";</span></span><br><span class="line">alert(instance.age); <span class="comment">//29</span></span><br></pre></td></tr></table></figure></p>
<p>方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的。</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承属性</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName(); <span class="comment">//"Nicholas";</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//29</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.sayName(); <span class="comment">//"Greg";</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure></p>
<p>最常用的方法，instanceof和isPrototypeOf()也能识别。</p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。<br>ES5 通过新增的Object.create()方法规范了原型式继承<br>var anotherperson = Object.create(person);</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>引用类型的属性还是会共享。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = object(original); <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">        alert(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">return</span> clone; <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); <span class="comment">//"hi"</span></span><br></pre></td></tr></table></figure></p>
<p>没法做到函数复用，效率低</p>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>组合继承是JavaScript 最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name); <span class="comment">//第二次调用SuperType()</span></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">//第一次调用SuperType()</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在第一次调用SuperType 构造函数时，SubType.prototype 会得到两个属性：name 和colors；它们都是SuperType 的实例属性，只不过现在位于SubType 的原型中。当调用SubType 构造函数时，又会调用一次SuperType 构造函数，这一次又在新对象上创建了实例属性name 和colors。于是，这两个属性就屏蔽了原型中的两个同名属性。<br>有两组name 和colors 属性：一组在实例上，一组在SubType 原型中。这就是调用两次SuperType 构造函数的结果。好在我们已经找到了解决这个问题方法——寄生组合式继承。<br>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">    prototype.constructor = subType; <span class="comment">//增强对象</span></span><br><span class="line">    subType.prototype = prototype; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数接收两个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor 属性，从而弥补因重写原型而失去的默认的constructor 属性。最后一步，将新创建的对象（即副本）赋值给子类型的原型。这样，我们就可以用调用inherit-Prototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个例子的高效率体现在它只调用了一次SuperType 构造函数，并且因此避免了在SubType.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用instanceof 和isPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
<h1 id="第七章-函数表达式"><a href="#第七章-函数表达式" class="headerlink" title="第七章 函数表达式"></a>第七章 函数表达式</h1><p>函数两种： 函数声明， 函数表达式<br>函数声明有函数提升， 即使先用函数再声明也没关系。但是函数表达式不行 ，它必须先声明再使用。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>arguments.callee 是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用。<br>不过这种方式在严格模式不能使用arguments.callee,需要借助命名函数表达式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个f 命名的函数表达式,然后将它赋值给变量factorial</span></span><br><span class="line">    <span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num * f(num - <span class="number">1</span>); <span class="comment">//函数f 依然有效</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(factorial(<span class="number">4</span>));<span class="comment">//返回24</span></span><br></pre></td></tr></table></figure></p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是指有权访问另一个函数作用域中的变量的函数， 创建闭包的常见方式，就是在一个函数中创建另一个函数。</p>
<p><strong>当某个函数被调用时， 会创建一个执行环境以及相应的作用域链，使用arguments和其他命名参数 的值来初始化函数的活动对象。</strong>作用域链中，外部函数活动对象总处于第二位。</p>
<p>无论什么时候在函数中访问 一个变量时，会从作用域中搜索具有相应名字的变量，当函数执行完成后，局部活动对象就会被销毁，内存中仅保存全局作用域。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://img-blog.csdnimg.cn/20190516021703278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI4NTcxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="闭包作用链细节"><a href="#闭包作用链细节" class="headerlink" title="闭包作用链细节:"></a>闭包作用链细节:</h3><p>在另一个函数内部定义的函数会将包含函数(即外部函数)的活动对象添加到他的作用域链中</p>
<p>内部定义的匿名函数的作用域链实际上会包含外部函数的活动对象</p>
<p>即使外部函数执行完毕,内部匿名函数依然不会被销毁,然后他依然引用这个活动对象,直至这个匿名函数被销毁后才会全部销毁</p>
<h3 id="闭包缺点"><a href="#闭包缺点" class="headerlink" title="闭包缺点"></a>闭包缺点</h3><p>闭包只能取得包含函数中任何变量的最后一个值,因为闭包保存的是整个变量对象,而不是某个特殊的变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            result[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//这是一个闭包</span></span><br><span class="line">                <span class="comment">//因为闭包保存的是整个createFunctions变量对象,所以当他执行完成的时候(for循环结束),</span></span><br><span class="line">                <span class="comment">//i是等于10的,所以就会是10,由始至终,闭包里面引用的都是一整个变量对象,而不是一个变量</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">//返回的是一个数组,数组里面每一个项目都是一个function</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> test = createFunctions();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//需要执行这个 function 才能够获取里面的值</span></span><br><span class="line">        <span class="built_in">console</span>.log(test[i]());<span class="comment">//都是10 </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="关于this对象"><a href="#关于this对象" class="headerlink" title="关于this对象"></a>关于this对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"the window"</span>;</span><br><span class="line">    <span class="keyword">var</span> object = &#123;</span><br><span class="line">        name: <span class="string">"my object"</span>,</span><br><span class="line">        <span class="comment">//返回一个匿名函数</span></span><br><span class="line">        getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//匿名函数里面又返回一个匿名函数(闭包)</span></span><br><span class="line">            <span class="comment">//当返回的时候,当前环境已经变成了全局环境了,搜索的话直接在当前活动对象(全局)找到了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.name; <span class="comment">//所以返回的是全局环境的 name</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//object.getNameFunc()返回一个函数,然后再加上(),这个函数就会执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(object.getNameFunc()());<span class="comment">//返回 the window</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"the window"</span>;</span><br><span class="line">    <span class="keyword">var</span> object = &#123;</span><br><span class="line">        name: <span class="string">"my object"</span>,</span><br><span class="line">        <span class="comment">//返回一个匿名函数</span></span><br><span class="line">        getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//将当前对象(当前这个function)引用保存起来</span></span><br><span class="line">            <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">//匿名函数里面又返回一个匿名函数(闭包)</span></span><br><span class="line">            <span class="comment">//当返回的时候,使用的是保存起来的这个对象引用,所以会返回这个对象的属性</span></span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> that.name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//object.getNameFunc()返回一个函数,然后再加上(),这个函数就会执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(object.getNameFunc()());<span class="comment">//返回 my object</span></span><br></pre></td></tr></table></figure>
<h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><p>相当于弄个匿名函数。匿名函数中定义的任何变量都会在执行结束时被销毁。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//块级作用域</span></span><br><span class="line">    &#125;());</span><br><span class="line">---------分解一下</span><br><span class="line">    ( <span class="comment">//第一对圆括号</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//块级作用域  </span></span><br><span class="line">    &#125;</span><br><span class="line">    ()<span class="comment">//第二对圆括号</span></span><br><span class="line">    );</span><br><span class="line"><span class="comment">//将函数声明包含在第一对中,表示他实际上是一个函数表达式</span></span><br><span class="line"><span class="comment">//而紧随其后的第二对圆括号会立即调用这个函数</span></span><br></pre></td></tr></table></figure></p>
<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>有权访问私有变量的方法叫做特权属性</p>
<h4 id="构造函数法"><a href="#构造函数法" class="headerlink" title="构造函数法"></a>构造函数法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//私有变量和私有函数</span></span><br><span class="line">        <span class="keyword">var</span> privateVariable = <span class="number">10</span>; </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//特权方法</span></span><br><span class="line">        <span class="comment">//因为这里作为闭包有权访问在构造函数定义的所有变量和函数</span></span><br><span class="line">        <span class="comment">//另外设置了this可以被调用</span></span><br><span class="line">        <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//外部只能通过这个方法访问私有属性和函数</span></span><br><span class="line">            privateVariable++;</span><br><span class="line">            <span class="keyword">return</span> privateFunction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>使用构造函数模式的缺点就是针对每个实例都会创建同样一组新方法</p>
<h4 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h4><p>这种方式<br>私有变量和函数是由实例共享(因为被闭包引用着这个块级作用域)<br>由于特权方法是在构造函数的原型上定义的,所以所有实例都使用同一个特权方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//私有变量和私有函数</span></span><br><span class="line">        <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造函数</span></span><br><span class="line">        MyObject = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//没有函数声明,使用函数表达式创建</span></span><br><span class="line">            <span class="comment">//因为函数声明只能构建局部函数,现在创建了一个全局函数</span></span><br><span class="line">            <span class="comment">//因为这是全局函数,所以也相对来说就是一个静态了.</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//公有/特权方法</span></span><br><span class="line">        <span class="comment">//在原型上定义方法,所有这个原型的实例都能共享</span></span><br><span class="line">        <span class="comment">//特权方法是一个闭包,保存着对包含作用域的引用(当前这个块级作用域)</span></span><br><span class="line">        MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//这个是一个闭包</span></span><br><span class="line">            privateVariable++;</span><br><span class="line">            <span class="keyword">return</span> privateFunction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br></pre></td></tr></table></figure></p>
<h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要一个单例来管理应用程序级的信息</span></span><br><span class="line">    <span class="comment">//创建一个application对象(返回单例对象)</span></span><br><span class="line">    <span class="keyword">var</span> application = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//初始化一个数组</span></span><br><span class="line">        <span class="keyword">var</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">        components.push(<span class="keyword">new</span> BaseComponent());</span><br><span class="line">        <span class="comment">//返回的单例可以使用方法,然后获取数组的长度或者添加数组内容</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            getComponentCount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> components.length;</span><br><span class="line">            &#125;,</span><br><span class="line">            registerComponent: <span class="function"><span class="keyword">function</span> (<span class="params">component</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">"object"</span>) &#123;</span><br><span class="line">                    components.push(component);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;();</span><br></pre></td></tr></table></figure>
<h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><p>bom的核心对象是windows,既是通过javascript访问浏览器的一个接口，又是ECMAScript规定的global对象<br>所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。</p>
<h2 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h2><p>如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt; Frameset Example&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>head&gt;</span><br><span class="line">  &lt;frameset rows=<span class="string">"160, *"</span>&gt;</span><br><span class="line">    &lt;frame src=<span class="string">"frame.htm"</span> name=<span class="string">"topFrame"</span>&gt;</span><br><span class="line">    &lt;frameset cols=<span class="string">"50%, 50%"</span>&gt;</span><br><span class="line">      &lt;frame src=<span class="string">"anotherframe.htm"</span> name=<span class="string">"leftFrame"</span>&gt;</span><br><span class="line">      &lt;frame src=<span class="string">"yetanotherframe.htm"</span> name=<span class="string">"rightFrame"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/frameset&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>frameset&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>top对象始终指向最高（最外层）的框架，也就是浏览器窗口。<br>与top相对的另一个window对象是parent。parent（父）对象始终指向当前框架的直接上层框架。在某些情况下parent有可能等于top,但在没有框架的情况下，parent一定等于top。此时他们都是window</p>
<h2 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h2><p>// 确定 screenLeft 和 screenTop 属性是否存在<br>// 存在，是在 IE, Safari, Opera, Chrome<br>// 否则，是在 Firefox中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>) ?</span><br><span class="line">                <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>) ?</span><br><span class="line">                <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure></p>
<h2 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h2><p>IE9+ Firefox Safari Opera Chrome 均为此提供了4个属性：innerwidth innerHeight outerWidth outerHeight。<br>IE9 Safari Firefox 中 outerWidth outerHeight 返回浏览器窗口本身的尺寸（无论是从最外层的window对象还是从某个框架访问）。<br>Opera中这两个属性的值表示页面视图容器的大小。<br>innerwidth innerHeight则表示容器中页面视图区的大小（减去边框宽度）。<br>Chrome 中 四个值返回的相同，即视口（viewport）大小而非浏览器窗口大小。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">先调用最基本的值，假如不是数字说明不支持，再调用<span class="built_in">document</span>.documentElement.clientWidth和<span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth;</span><br><span class="line"><span class="keyword">var</span> pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"></span><br><span class="line"><span class="comment">// document.compatMode 这个属性将在第10章讨论</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>) &#123;</span><br><span class="line">    pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">    pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">    pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h2><p>window.open() 方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。接受四个参数：</p>
<pre><code>要加载的URL
窗口目标 (窗口或者框架的名字以及特殊窗口名称： _self, _parent, _top, _blank)
特性字符串（新窗口的特性设置，逗号分隔）
表示新页面是否取代浏览器历史记录中当前加载页面的布尔值
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com"</span>, <span class="string">"topFrame"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="安全性屏蔽"><a href="#安全性屏蔽" class="headerlink" title="安全性屏蔽"></a>安全性屏蔽</h2><p>浏览器拓展程序（插件）或其他程序阻止弹窗，那么 window.open()通常会抛出错误。因此不但要检测返回值，还要将对 window.open()的调用封装在一个 try-catch 块中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bloacked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com"</span>, <span class="string">"_blank"</span>);</span><br><span class="line">  <span class="keyword">if</span> (wroxWin == <span class="literal">null</span>) &#123;</span><br><span class="line">    bloacked = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  bloacked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"The popup was blocked!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h2><p>间歇调用和超时调用<br>JavaScript是单线程语言，但它允许通过设置超时值和间歇值来调度代码在特定的时刻执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  alert(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<p>JavaScript是一个单线程解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JavaScript任务队列。这些任务会按照将他们添加到队列中的顺序执行。<br>第二个参数是告诉JavaScript再过多久把当前任务添加到队列中。之后如果队列是空的，那么添加的代码会立即执行，如果不是空的，那么就要等前面的代码执行完了以后再执行。<br>该方法会返回一个数值ID，这是计划执行代码的唯一标识符，可以通过它来取消超时调用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeoutId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  alert(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消执行</span></span><br><span class="line">clearTimeout(timeoutId);</span><br></pre></td></tr></table></figure></p>
<p>超时调用的代码都是在全局作用域中执行的，因此函数中 this 的值在非严格模式下 指向 window ，在严格模式下是 undefined。<br>setInterval()用法与上述类似</p>
<h2 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h2><p>alert(), confirm(), prompt() 方法可以调用系统对话框向用户显示消息。样式css没关系就是浏览器样式<br>alert不必多说<br>confirm会显示ok 还是cancel。 有if(confirm(“are you sure”)) 来完成<br>prompt() 返回一个字符串或者null，输入了值并确定，返回字符串，其他方法关闭返回null<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = promt(<span class="string">"what is you name"</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span>( result !== <span class="literal">null</span>)&#123;</span><br><span class="line">	alert(<span class="string">"welcome,"</span>+ result);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h2><p>location就是url相关<br>location是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供一些导航功能。<br>location 对象既是window对象的属性，也是document对象的属性；换言之，window.location document.location引用的是同一个对象。<br>location.hostname    “<a href="http://www.wrox.com&quot;" target="_blank" rel="noopener">www.wrox.com&quot;</a>    返回服务器名称不带端口号<br>location.pathname    “/WileyCDA/“    返回URL中的目录或者文件名</p>
<h3 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">funcction getQueryStringArgs() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取得查询字符串并去掉开头的问号</span></span><br><span class="line">  <span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存数据的对象</span></span><br><span class="line">  <span class="keyword">var</span> args = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取得每一项</span></span><br><span class="line">  <span class="keyword">var</span> items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : [];</span><br><span class="line">  <span class="keyword">var</span> item = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在for循环中使用</span></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> len = items.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 逐个将每一项添加到args对象中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    item = items[i].split(<span class="string">"="</span>);</span><br><span class="line">    name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]);</span><br><span class="line">    value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name.length) &#123;</span><br><span class="line">      args[name] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="位置操作-location"><a href="#位置操作-location" class="headerlink" title="位置操作 location"></a>位置操作 location</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">都可以改变location的地址。</span><br><span class="line">首先也是最常用的方式 assign()方法，并为其传递一个URL。立即打开新的URL并在浏览器的历史记录中生成一条记录。</span><br><span class="line">location.assign(<span class="string">"http://www.wrox.com"</span>);</span><br><span class="line"><span class="built_in">window</span>.location = <span class="string">"http://www.wrox.com"</span>;</span><br><span class="line">location.href = <span class="string">"http://www.wrox.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将URL修改为 http://www.wrox.com/wileyCDA/#section1</span></span><br><span class="line">location.hash = <span class="string">"#section1"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将URL修改为 http://www.wrox.com/wileyCDA/?q=javascript</span></span><br><span class="line">location.search = <span class="string">"?q=javascript"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将URL修改为 http://www.wrox.com/wileyCDA/</span></span><br><span class="line">location.hostname = <span class="string">"www.yahoo.com"</span></span><br></pre></td></tr></table></figure>
<p>通过上述任何一种方式修改URL之后，浏览器的历史记录中就会生成一条新纪录，因此用户通过单击“后退”按钮都会导航到前一个页面。要禁用这种行为，可以使用replace()方法。<br>调用replace()方法后用户不能回到上一个页面。<br>reload<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location.reload();<span class="comment">//重新加载（有可能从缓存中加载）</span></span><br><span class="line">location。reload(ture);<span class="comment">// 重新加载（从服务器中加载）</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h2><p>这个就是浏览器相关，有浏览器一些属性。</p>
<p>##检查插件<br>Navigator.plugins<br>一般来说name属性中会包含检测插件必需的所有信息，但有时候也不完全如此。在检测插件时，需要像下面这样循环代码每个插件并将插件的name与给定的名字进行比较<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测插件（在IE中无效）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  name = name.toLowerCase();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; navigator.plugins.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  检测flash</span></span><br><span class="line"><span class="built_in">console</span>.log(hasPlugin(<span class="string">"Flash"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//  检测QuickTime</span></span><br><span class="line"><span class="built_in">console</span>.log(hasPlugin(<span class="string">"QuickTime"</span>));</span><br></pre></td></tr></table></figure></p>
<p>对于ie浏览器要用new ActiveXObject(name),创建一个com对象的实例。如果实例化成功，说明插件可用。</p>
<h3 id="注册处理程序"><a href="#注册处理程序" class="headerlink" title="注册处理程序"></a>注册处理程序</h3><p>registerContentHandler() 和 registerProtocolHandler() 方法可以让一个站点知名它可以处理特定类型的信息。随着RSS阅读器和在线电子邮件程序的信息，注册处理程序就为像使用桌面应用程序一样默认使用这些在线应用程序提供了一种方式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要将一个站点注册为处理RSS源的处理程序</span></span><br><span class="line">navigator.registerContentHandler(<span class="string">"application/rss+xml"</span>,</span><br><span class="line">  <span class="string">"http://www.somereader.com?feed=%s"</span>, <span class="string">"Some Reader"</span>);</span><br></pre></td></tr></table></figure></p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 要将一个应用程序注册为默认的邮件客户端</span></span><br><span class="line">navigator.registerProtocolHandler(<span class="string">"mailto"</span>,</span><br><span class="line">  <span class="string">"http://www.somemailclient.com?cmd=%s"</span>, <span class="string">"Some Mail Client"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>history对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为history是window对象的属性<br>使用go()方法可以在用户的历史记录中任意跳转，可以向前向后，接受一个参数整数值或者字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">history.go(<span class="number">-1</span>);</span><br><span class="line">history.go(<span class="number">1</span>);</span><br><span class="line">history.forward();</span><br><span class="line">history.back();</span><br></pre></td></tr></table></figure></p>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>location主要针对url<br>navigator主要针对浏览器<br>screen没啥用</p>
<h1 id="第九章-客户端检测"><a href="#第九章-客户端检测" class="headerlink" title="第九章 客户端检测"></a>第九章 客户端检测</h1><h2 id="能力检测"><a href="#能力检测" class="headerlink" title="能力检测"></a>能力检测</h2><p>通常就用if语句<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (object.propertyInQuestion) &#123;</span><br><span class="line"><span class="comment">//使用object.propertyInQuestion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="更好的能力检测"><a href="#更好的能力检测" class="headerlink" title="更好的能力检测"></a>更好的能力检测</h2><p>有时候尽量用typeOf检测<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSortable</span>(<span class="params">object</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> object.sort == <span class="string">'function'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="浏览器检测"><a href="#浏览器检测" class="headerlink" title="浏览器检测"></a>浏览器检测</h2><p>检测某几个特性不能确定是不是哪个浏览器，下面两个例子就是用力过猛了，浏览器特性可能会变。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isFirefox = !!(navigator.vendor &amp;&amp; navigator.vendorSub); <span class="comment">// 不够具体</span></span><br><span class="line"><span class="keyword">var</span> isIE = !!(<span class="built_in">document</span>.all &amp;&amp; <span class="built_in">document</span>.uniqueID); <span class="comment">// 假设过度</span></span><br></pre></td></tr></table></figure></p>
<pre><code>重温一下双非操作符
双逻辑非操作，会把一个值（数字，字符串…..）转换为布尔值。第一次逻辑非操作取反的布尔，第二次获得最初元素本身对应的布尔。
</code></pre><p>应该将能力检测作为确定下一步解决方案的依据，而不是用它来判断用户使用的是什么浏览器。</p>
<h2 id="怪癖检测"><a href="#怪癖检测" class="headerlink" title="怪癖检测"></a>怪癖检测</h2><p>没啥好讲的，针对一些浏览器特有的怪癖。</p>
<h2 id="用户代理检测"><a href="#用户代理检测" class="headerlink" title="用户代理检测"></a>用户代理检测</h2><p>用户代理检测通过检测用户代理字符串来确定实际使用的浏览器。它通过JavaScript的navigator.userAgent属性访问。<br>chrome输入后得到，为了提高兼容性不被主流网站屏蔽，所以用了mozilla，这是另一个浏览器公司的标识符<br>“Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36”</p>
<h2 id="检测技术"><a href="#检测技术" class="headerlink" title="检测技术"></a>检测技术</h2><p>确切知道浏览器型号没啥意义，不如知道他的呈现引擎，主要5大呈现引擎：IE,Gecko,WebKit,KHTML,Opera.<br>完整的客户端，浏览器，和系统检测<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 呈现引擎</span></span><br><span class="line">    <span class="keyword">var</span> engine = &#123;</span><br><span class="line">        ie:<span class="number">0</span>,</span><br><span class="line">        gecko:<span class="number">0</span>,</span><br><span class="line">        webkit:<span class="number">0</span>,</span><br><span class="line">        khtml:<span class="number">0</span>,</span><br><span class="line">        opera:<span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完整的版本号</span></span><br><span class="line">        ver:<span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浏览器</span></span><br><span class="line">    <span class="keyword">var</span> browser = &#123;</span><br><span class="line">        <span class="comment">// 主要浏览器</span></span><br><span class="line">        ie:<span class="number">0</span>,</span><br><span class="line">        firefox:<span class="number">0</span>,</span><br><span class="line">        safari:<span class="number">0</span>,</span><br><span class="line">        konq:<span class="number">0</span>,</span><br><span class="line">        opera:<span class="number">0</span>,</span><br><span class="line">        chrome:<span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 具体的版本号</span></span><br><span class="line">        ver:<span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测呈现引擎和浏览器</span></span><br><span class="line">    <span class="keyword">var</span> ua = navigator.userAgent;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.opera) &#123;</span><br><span class="line">        engine.ver = browser.ver = <span class="built_in">window</span>.opera.version();</span><br><span class="line">        engine.opera = browser.opera = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/AppleWebKit\/(\S+)/</span>.test(ua)) &#123;</span><br><span class="line">        engine.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">        engine.webkit = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确定是Chrome还是Safari</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/Chrome\/(\S+)/</span>.test(ua)) &#123;</span><br><span class="line">            browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">            browser.chrome = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/Version\/(S+)/</span>.test(ua)) &#123;</span><br><span class="line">            browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">            browser.safari = <span class="built_in">parseFloat</span>(browser.ver);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 近似地确定版本号</span></span><br><span class="line">            <span class="keyword">var</span> safariVersion = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (engine.Webkit &lt;<span class="number">100</span>) &#123;</span><br><span class="line">                safariVersion = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (engine.webkit &lt; <span class="number">312</span>) &#123;</span><br><span class="line">                safariVersion = <span class="number">1.2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (engine.webkit &lt; <span class="number">412</span>) &#123;</span><br><span class="line">                safariVersion = <span class="number">1.3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                safariVersion = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            browser.safari = browser.ver = safariVersion;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/KHTML\/(S+)/</span>.test(ua) || <span class="regexp">/Konqueror\/([^;]+)/</span>.test(ua)) &#123;</span><br><span class="line">        engine.ver = browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">        engine.khtml = browser.kong = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/rv:([^\)]+)\) Gecko\/\d&#123;8&#125;/</span>.test(ua))&#123;</span><br><span class="line">        engine.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">        engine.gecko = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确定是不是firefox</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/Firefox\/(S+)/</span>.test(ua)) &#123;</span><br><span class="line">            browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">            browser.firefox = <span class="built_in">parseFloat</span>(browser.ver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/MSIE ([^;]+)/</span>.test(ua)) &#123;</span><br><span class="line">        engine.ver = browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">        engine.ie = browser.ie = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测浏览器</span></span><br><span class="line">    browser.ie = engine.ie;</span><br><span class="line">    browser.opera = engine.opera;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回这些对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        engine:engine,</span><br><span class="line">        browser: browser</span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(client.engine);</span><br><span class="line"><span class="built_in">console</span>.log(client.browser);</span><br></pre></td></tr></table></figure></p>
<p>还要识别系统，windows,mac,linux.windows不同版本号挺麻烦的，要用正则表达式<br>还要识别手机浏览器，游戏浏览器。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般情况下，先用能力检测和怪癖检测，实在不行再用用户代理检测。<br>能力检测：在编写代码之前先检测特定浏览器的能力。例如，脚本在调用某个函数之前，可能要先检测该函数是否存在。<br>怪癖检测：怪癖实际上是浏览器中的bug，怪癖检测通常涉及到运行一小段代码，然后确定浏览器是否存在某个怪癖，由于怪癖检测与能力检测相比效率更低，因此应该只在某个怪癖会干扰脚本运行时才使用。<br>用户代理检测：通过检测用户代理字符串来识别浏览器。用户代理字符串包含大量与浏览器有关的信息，包括浏览器、浏览器版本、平台、操作系统等。</p>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>这章转自<br><a href="https://www.kancloud.cn/crossken/professional_js_web_developers/207410" target="_blank" rel="noopener">https://www.kancloud.cn/crossken/professional_js_web_developers/207410</a><br>1.文档节点是每个文档的根节点。在HTML页面，文档节点始终都是元素，因此我们也称其为文档元素。</p>
<p>2.DOM1级定义了一个Node接口，该接口将由DOM中的所有节点类型实现。这个Node接口在JavaScript中是作为Node类型实现的。除了IE之外，在其他所有浏览器中都可以访问到这个类型。JavaScript中的所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。</p>
<p>3.每个节点都有一个nodeType属性，用于表明节点的类型。节点类型由在Node类型中定义的12个数值常量来表示。其中元素节点属性值为1，特性节点的属性值为2，文本节点的属性值为3。将nodeType属性与数字值比较可以检测其节点类型：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>)&#123;</span><br><span class="line">    alert(<span class="string">'Node is an element'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.要了解节点的具体信息，可以使用nodeName和nodeValue属性。其中nodeName保存着节点的具体名称（如标签的nodeName值为大写的‘P’，nodeValue始终为null）。</p>
<p>5.每个节点都有一个childNodes属性，其中保存着一个NodeList对象。NodeList对象是一种类数组对象，用于保存一组有序的节点。虽然可以使用方括号语法来访问其子项，而且这个对象也有length属性，但它并不是Array的实例。NodeList对象的独特之处在于，它实际上是基于DOM结构动态执行查询的结构，因此DOM结构的变化能够自动反映在NodeList对象中。将childNodes转换成数组的方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convetToArray</span>(<span class="params">nodes</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        array = <span class="built_in">Array</span>.prototype.slice.call(nodes,<span class="number">0</span>);<span class="comment">//针对非ie浏览器</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;nodes.length;i++) &#123;</span><br><span class="line">            array.push(nodes[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>元素节点内的空白符也会作为文本标签被childNodes所包含。</p>
<p>6.描述节点间关系的属性还有：parentNode、nextSibling、previousSibling、firstChild、lastChild</p>
<p>7.<strong>hasChildNodes()</strong>方法在节点包含一或多个子节点的情况下返回true。所有节点都有的最后一个属性是ownerDocument，该属性指向表示整个文档的文档节点，通过这个属性我们可以不必在节点层次中通过层层回溯到达顶端，而是可以直接访问文档节点。</p>
<p>8.<strong>appendChild()</strong>向节点末尾添加一个节点，并返回新增节点。如果传入到appendChild()中的节点已经是文档的一部分了，那相当于将节点剪切了。</p>
<p>9.<strong>insertBefore()</strong>方法将一个新节点插到指定节点前面，并返回这个新节点。这个方法接收两个参数：要插入的节点和作为参照的节点。如果参照节点是null则与appendChild()执行相同结果。insertBefore()同样可以实现剪切。</p>
<p>10.<strong>replaceChild()</strong>方法将一个新节点替换掉原节点，并返回原节点。</p>
<p>11.<strong>removeChild()</strong>方法删除一个节点。</p>
<p>12.以上四个方法操作的都是某个节点的子节点，也就是说，要使用这几个方法必须先取得父节点（使用parentNode属性）。</p>
<p>13.<strong>cloneNode()</strong>方法用于创建节点副本。若传入参数为true，则会进行深复制，即复制节点及其整个子节点树。否则只会复制原节点本身。cloneNode()方法不会复制添加到DOM节点中的JavaScriipt属性，例如事件处理程序等。</p>
<p>15.document.documentElement指向元素。document.body指向元素。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="built_in">document</span>.documentElement;</span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span><br></pre></td></tr></table></figure></p>
<p>16.通过document.title属性可以取得当前页面的标题（并非取得完整的title元素DOM对象），也可以修改当前页面的标题并反映在浏览器的标题栏中。修改title属性的值会改变</p>
<ol start="17">
<li>document.domain<br>如果URL 中包含一个子域名，例如p2p.wrox.com，那么就只能将domain设置为”wrox.com”，不能将这个属性设置为URL 中不包含的域。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设页面来自p2p.wrox.com 域</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">"wrox.com"</span>; <span class="comment">// 成功</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">"nczonline.net"</span>; <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>当页面中包含来自其他子域的框架或内嵌框架时，由于跨域安全限制，来自不同子域的页面无法通过JavaScript通信。而通过将每个页面的document.domain设置为相同的值，这些页面就可以互相访问对方包含的JavaScript对象了。比如有个页面加载自<a href="http://www.wrox.com,其中包含一个内嵌框架，框架内的页面加载自p2p.wrox.com" target="_blank" rel="noopener">www.wrox.com,其中包含一个内嵌框架，框架内的页面加载自p2p.wrox.com</a> 由于document.domian字符串不一样，内外两个页面之间无法相互访问对方的javascript对象，但如果将这两个页面的ducument.domain都设置成wrox.com，它们之间就能相互通信了
</strong></p>
<ol start="18">
<li><p>查找元素<br>getElementById();<br>getElementsByTagName();<br>getElementsByName();</p>
</li>
<li><p>文档写入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;strong&gt;"</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>()).toString() + <span class="string">"&lt;/strong&gt;"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>element 类型，每个属性比如dic，有div.id, div.classname, div.title, div.lang, </p>
</li>
<li>取得特性，三种方式， getAttribute(), setAttribute(), removeAttribute().</li>
<li>element.attributes可以得到所有attributes</li>
<li>创建元素，document.createElement(“div”)  div.id = “myNewDiv” div.className = “box”</li>
<li>子节点 ， childNodes 属性</li>
<li>text 类型 nodeType的值为3 nodeValue为所包含的文本 createTextNode() 创建文本节点</li>
<li>normalize()方法，将所有文本节点合成一个节点，splitText()将一个节点分成两个节点</li>
<li>comment类型 注释</li>
<li>CDATASection 类型 DocumentType类型 DocumentFragment类型（作为一个仓库转移文档）</li>
<li>动态脚本 一种<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"client.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>另一种<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">script.src=<span class="string">"client.js"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure></p>
<ol start="30">
<li>动态样式<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel = <span class="string">"stylesheet"</span> type = <span class="string">"text/css"</span> href = <span class="string">"styles.css"</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>还有一种方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadCss</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> link=<span class="built_in">document</span>.createElement(<span class="string">"link"</span>);</span><br><span class="line">link.rel=<span class="string">"stylesheet"</span>;</span><br><span class="line">link.href=url;</span><br><span class="line"><span class="keyword">var</span> head=<span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</span><br><span class="line">head.appendChild(link);</span><br><span class="line">&#125;</span><br><span class="line">loadCss(<span class="string">"http://www.damifanli.com/data/css/index_index_914724003.css"</span>)</span><br></pre></td></tr></table></figure></p>
<ol start="31">
<li><p>操作表格</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 table</span></span><br><span class="line"><span class="keyword">var</span> table = <span class="built_in">document</span>.createElement(<span class="string">"table"</span>);</span><br><span class="line">table.border = <span class="number">1</span>;</span><br><span class="line">table.width = <span class="string">"100%"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建tbody</span></span><br><span class="line"><span class="keyword">var</span> tbody = <span class="built_in">document</span>.createElement(<span class="string">"tbody"</span>);</span><br><span class="line">table.appendChild(tbody);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第一行</span></span><br><span class="line">tbody.insertRow(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"cell 1,1"</span>));</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">1</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"cell 2,1"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第二行</span></span><br><span class="line">tbody.insertRow(<span class="number">01</span>);</span><br><span class="line">tbody.rows[<span class="number">1</span>].insertCell(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">1</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"cell 1,2"</span>));</span><br><span class="line">tbody.rows[<span class="number">1</span>].insertCell(<span class="number">1</span>);</span><br><span class="line">tbody.rows[<span class="number">1</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"cell 2,2"</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(table);</span><br></pre></td></tr></table></figure>
</li>
<li><p>NodeList的动态性（还有NameNodeMap和HTMLCollection）</p>
</li>
<li>DOM会带来多次渲染和查询，非常影响性能，所以应该尽量减少操作<h1 id="第十一章-DOM扩展"><a href="#第十一章-DOM扩展" class="headerlink" title="第十一章 DOM扩展"></a>第十一章 DOM扩展</h1>querySelector()方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得body元素</span></span><br><span class="line"><span class="keyword">var</span> tbody = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得ID为"myDIV"的元素</span></span><br><span class="line"><span class="keyword">var</span> myDIV = <span class="built_in">document</span>.querySelector(<span class="string">"#myDiv"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得类为"selected"的第一个元素</span></span><br><span class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.querySelector(<span class="string">".selected"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得类为"button"的第一个图像元素</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.body.querySelector(<span class="string">"img.button"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>querySelectorAll()方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得某&lt;div&gt;中的所有&lt;em&gt;元素(类似于getElementsByTagName("em"))</span></span><br><span class="line"><span class="keyword">var</span> ems = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).querySelectorAll(<span class="string">"em"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得类为"selected"的所有元素</span></span><br><span class="line"><span class="keyword">var</span> selecteds = <span class="built_in">document</span>.querySelectorAll(<span class="string">".selected"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得所有&lt;p&gt;元素中的所有&lt;strong&gt;元素</span></span><br><span class="line"><span class="keyword">var</span> strongs = <span class="built_in">document</span>.querySelectorAll(<span class="string">"p strong"</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="html5"><a href="#html5" class="headerlink" title="html5"></a>html5</h2><h3 id="getElementsByClassName-方法"><a href="#getElementsByClassName-方法" class="headerlink" title="getElementsByClassName()方法"></a>getElementsByClassName()方法</h3><p>该方法可以通过document对象及所有HTML元素调用该方法。</p>
<h3 id="classlist属性"><a href="#classlist属性" class="headerlink" title="classlist属性"></a>classlist属性</h3><p>classlist有add, contains, remove,toggle等方法。可以对类名进行处理</p>
<h3 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h3><p>HTML5也添加了辅助管理DOM焦点的功能。首先就是document.activeElement属性，这个属性始终会引用DOM中当前获得了焦点的元素。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">"myButton"</span>);</span><br><span class="line">button.focus();</span><br><span class="line">alert(<span class="built_in">document</span>.activeElement === button); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>默认情况下，文档刚刚加载完成时，document.activeElement中保存的是document.body元素的引用。文档加载期间，docuemnt.activeElement的值为null。<br>另外就是新增了document.hasFocus()方法，这个方法用于确定文档是否获得了焦点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">"myButton"</span>);</span><br><span class="line">botton.focus();</span><br><span class="line">alert(<span class="built_in">document</span>.hasFocus()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="HTMLDocument的变化"><a href="#HTMLDocument的变化" class="headerlink" title="HTMLDocument的变化"></a>HTMLDocument的变化</h2><p>document的readystate 分loading complete<br>document.head属性<br>document.charset<br>自定义数据属性 data-appId   html5可以为元素添加非标准的属性<br><a href="https://segmentfault.com/a/1190000010995841" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010995841</a></p>
<h3 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h3><p>innerHTML就是一个属性可以获得一段html代码  div.innerHTML = </p>
<h3 id="outerHTML"><a href="#outerHTML" class="headerlink" title="outerHTML"></a>outerHTML</h3><p>在读模式下，outerHTML 返回调用它的元素及所有子节点的 HTML 标签。在写模式下，outerHTML 会根据指定的 HTML 字符串创建新的 DOM 子树。然后用这个 DOM 子树完全替换调用元素。</p>
<h3 id="insertAdjacentHTML-方法"><a href="#insertAdjacentHTML-方法" class="headerlink" title="insertAdjacentHTML()方法"></a>insertAdjacentHTML()方法</h3><p>语法：insertAdjacentHTML(插入位置，要插入的HTML文本)<br>插入位置必须是下列四个值之一：</p>
<p>“beforebegin”，在当前元素之前插入一个紧邻的同辈元素<br>“afterend”，在当前元素之后插入一个紧邻的同辈元素<br>“afterbegin”，给当前元素插入第一个子元素（不管当前元素是否有无子元素）<br>“beforeend”，给当前元素插入最后一个子元素（不管当前元素是否有无子元素）</p>
<h3 id="用以上方法的一些问题"><a href="#用以上方法的一些问题" class="headerlink" title="用以上方法的一些问题"></a>用以上方法的一些问题</h3><p>会造成内存泄漏，比如某个元素以及与事件处理函数绑定了，你假如删除或者替换了他，但它还在内存中<br>并且innerhtml之类的不能太多，因为它运行时要调用html解析器，耗内存的。</p>
<h3 id="scrollIntoView"><a href="#scrollIntoView" class="headerlink" title="scrollIntoView"></a>scrollIntoView</h3><p>所有HTML元素均可调用该方法，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。<br>该方法参数的取值有两种可能：<br>true：窗口滚动之后会让调用元素的顶部与视口顶部尽可能平齐（不传入参数时也会出现这种效果）<br>false：调用元素会尽可能全部出现在视口中，调用元素的底部会与视口顶部平齐。</p>
<h2 id="其他拓展功能"><a href="#其他拓展功能" class="headerlink" title="其他拓展功能"></a>其他拓展功能</h2><h3 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h3><p>document.documentMode</p>
<h3 id="children属性"><a href="#children属性" class="headerlink" title="children属性"></a>children属性</h3><p>返回调用元素的元素子节点</p>
<h3 id="contains-方法"><a href="#contains-方法" class="headerlink" title="contains()方法"></a>contains()方法</h3><p>检测某节点是不是另一个节点的后代</p>
<h3 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h3><p>1 innerText属性<br>得到所有文本值<br>2 outerText属性<br>替换指定文本的值</p>
<h1 id="第十二章-DOM2和DOM3"><a href="#第十二章-DOM2和DOM3" class="headerlink" title="第十二章 DOM2和DOM3"></a>第十二章 DOM2和DOM3</h1><p>这章没必要看<br>有些笔记转载<br><a href="https://blog.csdn.net/crystal6918/article/details/52911787" target="_blank" rel="noopener">https://blog.csdn.net/crystal6918/article/details/52911787</a><br><a href="https://www.jianshu.com/p/3814c40083bd?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">https://www.jianshu.com/p/3814c40083bd?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a><br>遍历<br>“DOM2 级遍历和范围”模块定义了两个用于辅助完成顺序遍历 DOM 结构的类型：NodeIterator 和 TreeWalker。这两个类型能够基于给定的起点对 DOM 结构执行深度优先（depth-first）的遍历操作。</p>
<h1 id="第十三章-事件"><a href="#第十三章-事件" class="headerlink" title="第十三章 事件"></a>第十三章 事件</h1><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流描述的是从页面中接受事件的顺序，ie的事件流是事件冒泡流，而netscape的事件流是事件捕获流</p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>事件冒泡即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点。从具体那个div沿着dom树向上传播，每一个节点都会发生，直到传播到document对象。</p>
<h2 id="事件冒泡-1"><a href="#事件冒泡-1" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>正好相反。他一般是从document到html到body到div</p>
<h2 id="dom事件流"><a href="#dom事件流" class="headerlink" title="dom事件流"></a>dom事件流</h2><p>『DOM2级事件』规定的事件流流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。使”DOM2级事件”规范明确要求捕获阶段不会涉及事件目标，但现代浏览器都会在捕获阶段触发事件对象上的事件。结果，就是有两个机会在目标对象上面操作事件。</p>
<h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><h2 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h2><p>就是把事件加在html里面，比如这样<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span> = <span class="string">"Click me"</span> <span class="attr">onclick</span>=<span class="string">"alert('I was clicked')"</span> /<span class="attr">input</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这个动态创建的函数，另一个有意思的地方是它扩展作用域的方式。在这个函数内部，可以像访问局部变量一样访问document及该元素本身的成员。如果当前元素是一个表单输入元素，则作用域中还会包含访问表单元素（父元素）的入口。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">with</span>(<span class="built_in">document</span>)&#123;</span><br><span class="line">    	<span class="keyword">with</span>(<span class="keyword">this</span>.form)&#123;</span><br><span class="line">        	<span class="keyword">with</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            	<span class="comment">//元素属性值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用这个方法可能存在一个问题，刚把html加载出来，js还没加载用户就点击了，这导致了无效。”时差问题“</p>
<h2 id="DOM0"><a href="#DOM0" class="headerlink" title="DOM0"></a>DOM0</h2><p>on开头的称位DOM0级事件处理程序，因为简单和跨浏览器现在还在使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>)l</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DOM0级事件处理程序中的this引用当前元素。以这种方式添加的事件处理程序会<strong>在事件冒泡阶段被处理。</strong>将事件处理程序设置为null可以删除通过DOM0级方法指定的事件处理程序。（此方法也可以删除HTML指定的事件处理程序）</p>
<h2 id="DOM2事件处理程序"><a href="#DOM2事件处理程序" class="headerlink" title="DOM2事件处理程序"></a>DOM2事件处理程序</h2><p>DOM中采用了addEventListener()和removeEventListener()来分配和移除事件处理函数。与IE不同的是这些方法有三个参数，第三个参数标识是用于冒泡阶段还是捕获阶段。用于捕获阶段为true，用于冒泡阶段则为false。移除时第三个参数要跟添加时保持一致<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fnClick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      alert(<span class="string">"Clicked"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fnClick2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      alert(<span class="string">"Click2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oDiv=<span class="built_in">document</span>.getElementById(<span class="string">"div"</span>);</span><br><span class="line">oDiv.addEventListener(<span class="string">"onclick"</span>,fnClick,<span class="literal">false</span>);</span><br><span class="line">oDiv.addEventListener(<span class="string">"onclick"</span>,fnClick2,<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">oDiv.removeEventListener(<span class="string">"onclick"</span>,fnClick,<span class="literal">false</span>);</span><br><span class="line">oDiv.removeEventListener(<span class="string">"onclick"</span>,fnClick2,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>与DOM0级方法相同，DOM2级方法添加的事件处理程序也是在其依附的元素的作用域中运行。使用DOM2级方法的主要好处是可以添加多个事件处理程序，事件处理程序会按照添加它们的顺序触发。<br>通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除，移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿名函数将无法移除。</p>
<h2 id="IE事件处理"><a href="#IE事件处理" class="headerlink" title="IE事件处理"></a>IE事件处理</h2><p>IE在监听事件必须用他自己的方法：attachEvent(),detachEvent()他们都接受2个参数：事件类型，和事件处理函数。但是必须用具有特色的IE on名称 类型。<br>1.顺序和DOM不同的是相反，先添加后执行<br>2.代码中的this指向不同，IE指向window、DOM指向目标元素作用域</p>
<h2 id="跨浏览器处理"><a href="#跨浏览器处理" class="headerlink" title="跨浏览器处理"></a>跨浏览器处理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">    addEvent: <span class="function"><span class="keyword">function</span> (<span class="params">el, eventType, fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (el.addEventListener) &#123;</span><br><span class="line">        el.addEventListener(eventType, fn, <span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.attachEvent) &#123;</span><br><span class="line">        el.attachEvent(<span class="string">'on'</span> + eventType, fn);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el[<span class="string">'on'</span> + eventType] = fn;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeEvent: <span class="function"><span class="keyword">function</span> (<span class="params">el, eventType, fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (el.removeEventListener) &#123;</span><br><span class="line">        el.removeEventListener(eventType, fn, <span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.detachEvent) &#123;</span><br><span class="line">        el.detachEvent(<span class="string">'on'</span> + eventType, fn);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el[<span class="string">'on'</span> + eventType] = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象包含着所有与事件有关的信息。只有在事件处理程序执行期间，event对象才会存在，一旦事件处理程序执行完成，event对象就会被销毁。</p>
<p>currentTarget：正在处理事件的那个元素<br>target：事件的目标<br>type：事件类型<br>cancelable：可以阻止特定事件的默认行为<br>preventDefault()：阻止特定事件的默认行为<br>stopPropagation()：停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡<br>eventPhase：事件出于事件流的阶段 捕获阶段为1 处于目标对象为2 冒泡阶段为3</p>
<p>阻止特定事件的默认行为，使用preventeDefault（）方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link  = <span class="built_in">document</span>.getElementById(<span class="string">"myLink"</span>);</span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>阻止冒泡<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">       btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">           alert(<span class="string">"Clicked"</span>);</span><br><span class="line">           event.stopPropagation();</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="comment">//click事件根本不会传播到document.body，因为阻止冒泡</span></span><br><span class="line">       <span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">           alert(<span class="string">"Body clicked"</span>);</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="ie事件对象"><a href="#ie事件对象" class="headerlink" title="ie事件对象"></a>ie事件对象</h3><p>IE了，阻止默认行为 returnValue = false，阻止捕获或者冒泡 cancelBubble。</p>
<h3 id="跨浏览器事件对象"><a href="#跨浏览器事件对象" class="headerlink" title="跨浏览器事件对象"></a>跨浏览器事件对象</h3><p>结合一般事件对象和ie进行封装<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">    addEvent: <span class="function"><span class="keyword">function</span> (<span class="params">el, eventType, fn</span>) </span>&#123;<span class="comment">//绑定事件</span></span><br><span class="line">      <span class="keyword">if</span> (el.addEventListener) &#123;</span><br><span class="line">        el.addEventListener(eventType, fn, <span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.attachEvent) &#123;</span><br><span class="line">        el.attachEvent(<span class="string">'on'</span> + eventType, fn);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el[<span class="string">'on'</span> + eventType] = fn;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeEvent: <span class="function"><span class="keyword">function</span> (<span class="params">el, eventType, fn</span>) </span>&#123;<span class="comment">//移除事件</span></span><br><span class="line">      <span class="keyword">if</span> (el.removeEventListener) &#123;</span><br><span class="line">        el.removeEventListener(eventType, fn, <span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.detachEvent) &#123;</span><br><span class="line">        el.detachEvent(<span class="string">'on'</span> + eventType, fn);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el[<span class="string">'on'</span> + eventType] = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getEvent: <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;<span class="comment">//获取事件对象</span></span><br><span class="line">      <span class="keyword">return</span> ev ? ev : <span class="built_in">window</span>.ev;</span><br><span class="line">    &#125;,</span><br><span class="line">    getTarget: <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;<span class="comment">//获取元素</span></span><br><span class="line">      <span class="keyword">return</span> ev.target || ev.srcElement;</span><br><span class="line">    &#125;,</span><br><span class="line">    preventDefault: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;<span class="comment">//阻止默认行为</span></span><br><span class="line">      <span class="keyword">if</span> (ev.preventDefault) &#123;</span><br><span class="line">        ev.preventDefault();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ev.returnValue = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    stopPropagation: <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;<span class="comment">//阻止冒泡或捕获</span></span><br><span class="line">      <span class="keyword">if</span> (ev.stopPropagation) &#123;</span><br><span class="line">        ev.stopPropagation();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ev.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><h3 id="UI事件：不一定与用户操作有关的事件"><a href="#UI事件：不一定与用户操作有关的事件" class="headerlink" title="UI事件：不一定与用户操作有关的事件"></a>UI事件：不一定与用户操作有关的事件</h3><p>DOMActive 不建议使用<br>load<br>当页面完全加载后再window上面触发，当作有框架都加载完毕时在框架集上触发，当图像加载完毕时在元素上触发，或者当嵌入内容加载完毕时在元素上触发。<br>图片load事件应用（最重要的是要在指定src属性之前先指定事件。）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	alert(<span class="string">'Image loaded!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    image.src = <span class="string">'smile.gif'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>unload<br>事件被完全卸载后触发<br>abort<br>error<br>resize<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般事件就是这样触发的</span></span><br><span class="line">EventUtil.addHandler(windows, <span class="string">"resize"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"Resized"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>scroll</p>
<h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3><p>blur 失去焦点时 不会冒泡<br>DOMFocusIn 获得焦点 冒泡<br>DOMFocusOut 失去焦点<br>focus 获得焦点 不会冒泡<br>focusin<br>focusout</p>
<h3 id="鼠标与滚轮事件"><a href="#鼠标与滚轮事件" class="headerlink" title="鼠标与滚轮事件"></a>鼠标与滚轮事件</h3><p>鼠标事件包含click、dblclick、mousedown、mouseout、mouseover、mouseup、mousemove。<br>click事件顺序： mousedown、mouseup、click<br>事件顺序：dblclick事件会先后触发以下事件：mousedown、mouseup、click、mousedown、mouseup、click、dblclick。<br>通过event.clientX 和event.clientY取得鼠标事件客户端坐标信息<br>还有pageX和pageY ,在页面不滚动情况下与上面client一样<br>screenX和screenY</p>
<h3 id="键盘与文本事件"><a href="#键盘与文本事件" class="headerlink" title="键盘与文本事件"></a>键盘与文本事件</h3><p>keydown<br>keypress<br>keyup<br>事件顺序：用户按一次某字符按键时，会先后触发以下事件：keydown、keypress、keyup。如果按一次某非字符按键时，会先后触发以下事件：keydown、keyup。<br>keypress按下之后，event里面又两个属性 charCode 和keyCode,前者是accii码，后者有规定</p>
<p>Dom3 新事件 textoutput</p>
<h3 id="复合事件"><a href="#复合事件" class="headerlink" title="复合事件"></a>复合事件</h3><h3 id="变动事件"><a href="#变动事件" class="headerlink" title="变动事件"></a>变动事件</h3><p>dom树中某一部分变化时触发不同事件<br>比如removeChild, appendChild</p>
<h3 id="HTML5-事件"><a href="#HTML5-事件" class="headerlink" title="HTML5 事件"></a>HTML5 事件</h3><p>关闭页面时出发的是event.beforeunload<br>readystatechange事件 readystate属性 uninitialized loading loaded interactive complete</p>
<p>readystatechange 事件，支持readystatechange事件的每个属性 uninitialized loading loaded interactive complete</p>
<p>pageshow和pagehide事件<br>往返缓存（back-forward cache，或bfcache）,用户使用浏览器的“后退”、“前进”按钮加快页面的转换速度。将整个页面保存在内存里。</p>
<p>html5新增了hashchange事件，在url发生变化时通知开发人员<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"hashchange"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"Old URL:"</span> + event.oldURL+<span class="string">"\nNew URL: "</span> + event.newURL);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="设备事件"><a href="#设备事件" class="headerlink" title="设备事件"></a>设备事件</h3><h3 id="触摸与手势事件"><a href="#触摸与手势事件" class="headerlink" title="触摸与手势事件"></a>触摸与手势事件</h3><h2 id="键盘-与文本事件"><a href="#键盘-与文本事件" class="headerlink" title="键盘 与文本事件"></a>键盘 与文本事件</h2><h2 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h2><p>事件处理程序是函数。在JavaScript中，每个函数都是对象，都会占用内存。内存中的对象越多，性能就越差。（dom访问次数上去了，延迟了整个页面的交互事件）</p>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>转自 <a href="https://segmentfault.com/a/1190000018826803" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018826803</a><br>目的：解决“事件处理程序过多”问题。<br>实现：利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。<br>使用事件委托，只需要在 DOM 树中尽量最高的层次上添加一个事件处理程序。<br>如下例子，由于所有列表项都是这个元素”myLinks”的子节点，而且它们的事件会冒泡，所以单击事件最终会被这个函数处理。 这样只操作了一次dom<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Event Delegation Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"EventUtil.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myLinks"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"goSomewhere"</span>&gt;</span>Go somewhere<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"doSomething"</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"sayHi"</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">"myLinks"</span>);</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">        EventUtil.addHandler(list, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">            event = EventUtil.getEvent(event);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> target = EventUtil.getTarget(event);</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">            <span class="keyword">switch</span>(target.id)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">"doSomething"</span>:</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.title = <span class="string">"I changed the document's title"</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">"goSomewhere"</span>:</span></span><br><span class="line"><span class="javascript">                    location.href = <span class="string">"http://www.wrox.com"</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">"sayHi"</span>:</span></span><br><span class="line"><span class="javascript">                    alert(<span class="string">"hi"</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    &#125;)();</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h2><p>有时候我们 操作dom直接removeChild()或者.innerHTML。 那么原来绑定在元素中的事件处理程序没法垃圾回收。<br>所以如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	btn.onclick = <span class="literal">null</span>;</span><br><span class="line">	<span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML = <span class="string">"processing..."</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>卸载页面是也会造成”空事件处理程序“<br>所以有onload的地方，都要用onunload处理了。</p>
<h2 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h2><p>模拟事件就是用js操作模拟鼠标或者键盘的行为<br>用createEvent来创建， dispatchEvent(event）;来执行</p>
<p>对于鼠标 用event.initMouseEvent来初始化<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</span><br><span class="line"><span class="comment">//创建事件对象</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">'MouseEvents'</span>);</span><br><span class="line"><span class="comment">//初始化对象</span></span><br><span class="line">event.initMouseEvent(<span class="string">'click'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="built_in">document</span>.defaultView,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="number">0</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//触发事件</span></span><br><span class="line">btn.dispatchEvent(event);</span><br></pre></td></tr></table></figure></p>
<p>ie模拟事件<br>document.createEventObject();<br>btn.fireEvent()</p>
<h1 id="表单脚本"><a href="#表单脚本" class="headerlink" title="表单脚本"></a>表单脚本</h1><p>在HTML中，表单是由 <form> 元素来表示的，而在 JavaScript 中，表单对应的则是 HTMLFormElement 类型。</form></p>
<h2 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h2><p>创建提交按钮<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通用提交按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit Form"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自定义提交按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit Form<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 图像按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"image"</span> <span class="attr">src</span>=<span class="string">"graphic.gif"</span> &gt;</span></span><br></pre></td></tr></table></figure></p>
<p>以这种方式提交表单时，浏览器会在将请求发送给服务器之前触发 submit 事件。</p>
<h2 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://github.com/"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"用户名"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"pwd"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 以下两种方式都可以定义重置按钮 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"重置表单"</span>&gt;</span>  </span><br><span class="line">  <span class="comment">&lt;!-- &lt;button&gt;重置表单&lt;/button&gt;   --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="表单字段"><a href="#表单字段" class="headerlink" title="表单字段"></a>表单字段</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> field1 = form.element[<span class="number">0</span>];<span class="comment">//取得表单第一个字段</span></span><br><span class="line"><span class="keyword">var</span> field2 = form.element[<span class="string">"textbox1"</span>];<span class="comment">//取得名为”textbox1“的字段</span></span><br><span class="line"><span class="keyword">var</span> fieldCount = form.elements.length;<span class="comment">//取得表单中包含的字段的数量</span></span><br></pre></td></tr></table></figure>
<h3 id="共有表单字段方法"><a href="#共有表单字段方法" class="headerlink" title="共有表单字段方法"></a>共有表单字段方法</h3><p>focus() 方法：用于将浏览器的焦点设置到表单字段，即激活表单字段，使其可以响应键盘事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(window, &quot;load&quot;, function(event)&#123;</span><br><span class="line">	document.forms[0].elements[0].focus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>blur() 方法：作用是从元素中移走焦点。<br>注意：HTML5为表单字段新增了一个autofocus属性，不用JavaScript就能自动把焦点移动到相应字段。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">autofocus</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>blur：当前子弹失去焦点时触发<br>change：对于input和textarea元素来说，在他们是去焦点并且值改变时触发，对于select元素，在其选项改变时触发，<br>focus：当前字段获得焦点时触发</p>
<h2 id="文本框脚本"><a href="#文本框脚本" class="headerlink" title="文本框脚本"></a>文本框脚本</h2><p>对于input元素来说可以通过size特性来设置能够显示的字符数，通过value特性，可以设置初始值。，而maxlength则可以指定能够接受的最大字符数。如果要创建一个文本框，让他能够显示25个字符，单输入不能超过50个字符。可以用如下代码。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">size</span>=<span class="string">"25"</span> <span class="attr">maxlength</span>=<span class="string">"50"</span> <span class="attr">value</span>=<span class="string">"initial value"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>但是对于<textarea>而言，元素始终会呈现为一个多行文本，要指定文本框的大小可以通过rows和cols,rows表示行数，cols表示列数。与元素的区别在于其初始值需要放在</textarea><textarea>initial value</textarea><textarea>之间。并且不能指定最大字符数。</textarea></p>
<h2 id="选择脚本"><a href="#选择脚本" class="headerlink" title="选择脚本"></a>选择脚本</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testbox = <span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="string">"textbox1"</span>];</span><br><span class="line">textbox.select();</span><br></pre></td></tr></table></figure>
<p>取得选择的文本<br>HTML5为取得选择的文本，添加了两个属性：selectionStart和selectionEnd</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSelectedText</span>(<span class="params">textbox</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> textbox.value.substring(textbox.selectionStart, textbox.selectionEnd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HTML5提供了选择部分文本的方法setSelectionRange()：接收两个参数：要选择的第一个字符的索引和要选择的最后一个字符之后的字符的索引。</p>
<h2 id="过滤输出"><a href="#过滤输出" class="headerlink" title="过滤输出"></a>过滤输出</h2><p>如果只想屏蔽特定的字符，则需要检测 keypress 事件对应的字符编码，然后再决定如何响应。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">EventUtil.addHandler(textbox, <span class="string">"keypress"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">event = EventUtil.getTarget(event);</span><br><span class="line"><span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line"><span class="keyword">var</span> charCode = EventUtil.getCharCode(event);</span><br><span class="line"><span class="keyword">if</span> (!<span class="regexp">/\d/</span>.test(<span class="built_in">String</span>.fromCharCode(charCode))) &#123;</span><br><span class="line">	EventUtil.preventDefault(event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="操作剪贴板"><a href="#操作剪贴板" class="headerlink" title="操作剪贴板"></a>操作剪贴板</h2><p>下列就是6个剪贴板事件：</p>
<p>beforecopy：在发生复制操作前触发；<br>copy：在发生复制操作时触发；<br>beforecut：在发生剪切操作前触发；<br>cut：在发生剪切操作时触发；<br>beforepaste：在发生粘贴操作前触发；<br>paste：在发生粘贴操作时触发；</p>
<p>访问剪贴板中的数据<br>clipboardData</p>
<h2 id="自动切换焦点"><a href="#自动切换焦点" class="headerlink" title="自动切换焦点"></a>自动切换焦点</h2><p>使用js可以从多个方面增强表单的易用性，其中，最常见的一种方式就是在用户填写完当前字段的时候，自动将焦点切换到下一个字段。通常在自动切换焦点之前，必须知道用户已经输入了既定的长度的数据（比如电话号码）。</p>
<h2 id="html5新增表单功能"><a href="#html5新增表单功能" class="headerlink" title="html5新增表单功能"></a>html5新增表单功能</h2><p>必填字段：required属性；<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"username"</span> <span class="attr">requied</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>其他输入类型：email和url等；<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"email"</span> <span class="attr">name</span> = <span class="string">"email"</span> &gt;</span></span><br></pre></td></tr></table></figure></p>
<p>数值范围：number、range等；<br>输入模式：pattern属性；<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">pattern</span>  = <span class="string">"\d+"</span> <span class="attr">name</span> = <span class="string">"count"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>检测有效性：checkValidity()方法，validity属性则会告诉你为什么字段有效或无效；<br>禁用验证：novalidate属性；<br>通过设置novalidate（在<form>y=元素上使用），可以告诉表单不进行验证；<br>如果一个表单有多个提交按钮，对其中的一个按钮添加formnovalidate属性，可以使相应的提交按钮不必验证表单</form></p>
<h2 id="选择框脚本"><a href="#选择框脚本" class="headerlink" title="选择框脚本"></a>选择框脚本</h2><p>选择框是通过 <select> 和 <option> 元素创建的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selectbox = <span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="string">"location"</span>];</span><br><span class="line"><span class="keyword">var</span> text = selectbox.options[<span class="number">0</span>].text;  <span class="comment">//选项的文本</span></span><br><span class="line"><span class="keyword">var</span> value = selectbox.options[<span class="number">0</span>].value; <span class="comment">//选项的值</span></span><br></pre></td></tr></table></figure></option></select></p>
<h3 id="选择选项"><a href="#选择选项" class="headerlink" title="选择选项"></a>选择选项</h3><p>对于只允许选择一项的选择框，访问选中项的最简单方式，就是使用选择框的 selectedIndex 属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selectedOption  = selectbox.options[selectbox.selectedIndex];</span><br></pre></td></tr></table></figure></p>
<p>另一种选择选项的方式，就是取得对某一项的引用，然后将其 selected 属性设置为 true 。</p>
<h3 id="添加选项"><a href="#添加选项" class="headerlink" title="添加选项"></a>添加选项</h3><p>采用DOM方法；<br>使用 Option 构造函数来创建新选项，它接受两个参数：文本(text) 和值 (value)（可选）；<br>使用选择框的 add() 方法，接受两个参数：要添加的新选项和将位于新选项之后的选项。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newOption = <span class="keyword">new</span> Option(<span class="string">"Option text"</span>, <span class="string">"Option value"</span>);</span><br><span class="line">selectbox.add(newOption, <span class="literal">undefined</span>);             <span class="comment">// 最佳方案</span></span><br></pre></td></tr></table></figure></p>
<h3 id="移除选项"><a href="#移除选项" class="headerlink" title="移除选项"></a>移除选项</h3><p>使用DOM的removeChild() 方法，为其传入要移除的选项；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectbox.removeChild(selectbox.options[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></p>
<p>使用选择框的 remove() 方法，接受一个参数，即要移除选项的索引；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectbox.remove(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>将相应选项设置为 null；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectbox.options[<span class="number">0</span>] = nul;</span><br></pre></td></tr></table></figure></p>
<h3 id="移动和重排选项"><a href="#移动和重排选项" class="headerlink" title="移动和重排选项"></a>移动和重排选项</h3><p>使用 DOM 的 appendChild() 方法，可以将第一个选择框中的选项直接移动到第二个选择框中。<br>要将选择框中的某一项移动到特定位置，最合适的 DOM 方法就是 insertBefore()。</p>
<h2 id="表单序列化"><a href="#表单序列化" class="headerlink" title="表单序列化"></a>表单序列化</h2><p>ajax出现后， 你要把表单数据给服务器得先把他序列化了吧，比如不发送submit得按钮， 只发送选中得select<br>1 对表单字段的名称和值进行URL(encodeURIComponent())编码,并使用(&amp;)进行分割<br>2 不发送禁用的表单字段<br>3 只发送勾选的复选框和单选按钮<br>4 不发送type为reset和button的按钮<br>5 多选框中每个选中的值单独一个条目<br>6 在单击提交按钮提交表单的情况下，也会发送提交按钮；否则不会发送，也包括type为image的input元素<br>7 <select>元素的值就是选中的 <option>元素的value值，如果</option><option>元素没有value�特性则 </option><option>的文本值</option></select></p>
<h2 id="富文本编辑"><a href="#富文本编辑" class="headerlink" title="富文本编辑"></a>富文本编辑</h2><h3 id="使用创建富文本编辑区域"><a href="#使用创建富文本编辑区域" class="headerlink" title="使用创建富文本编辑区域"></a>使用<iframe>创建富文本编辑区域</iframe></h3><p>设置其designMode属性，可以使这个空白的HTML页面可以被编辑</p>
<h3 id="使用contenteditable属性"><a href="#使用contenteditable属性" class="headerlink" title="使用contenteditable属性"></a>使用contenteditable属性</h3><p>把contenteditable属性应用给页面中的任何元素，用户立即就可以编辑该元素。</p>
<h3 id="操作富文本"><a href="#操作富文本" class="headerlink" title="操作富文本"></a>操作富文本</h3><p>document.execCommand()方法：对文档执行预定义的命令，接收3个参数：要执行的命令名称、表示浏览器是否应该为当前命令提供用户界面的一个布尔值（通常设为false）和执行命令必须的一个值（如果不需要值，则传递null）。</p>
<p>与命令相关的方法：</p>
<p>queryCommandEnabled()方法：用来检测是否针对当前选择的文本，或者当前插入字符所在位置执行某个命令，接收一个参数即要检测的命令。<br>queryCommandState()方法：用于确定是否已经将指定命令应用到了选择的文本。<br>queryCommandValue()方法：用于取得执行命令时传入的值。</p>
<h3 id="富文本选区"><a href="#富文本选区" class="headerlink" title="富文本选区"></a>富文本选区</h3><p>在富文本编辑器中，使用框架的（iframe）的getSelection()方法，可以确定实际选择的文本，返回一个表示当前选择文本的Selection对象。</p>
<h3 id="表单与富文本"><a href="#表单与富文本" class="headerlink" title="表单与富文本"></a>表单与富文本</h3><p>由于富文本编辑器是使用iframe而非表单控件实现的，因此在将其内容提交给服务器之前，必须将iframe或contenteditable元素中的HTML复制到一个表单字段中。</p>
<h1 id="第16章-HTML5脚本编程"><a href="#第16章-HTML5脚本编程" class="headerlink" title="第16章 HTML5脚本编程"></a>第16章 HTML5脚本编程</h1><h2 id="跨文档消息传递"><a href="#跨文档消息传递" class="headerlink" title="跨文档消息传递"></a>跨文档消息传递</h2><p><a href="http://www.wrox.com域中的页面与位于一个内嵌框架中的p2p.wrox.com域中的页面通信。" target="_blank" rel="noopener">www.wrox.com域中的页面与位于一个内嵌框架中的p2p.wrox.com域中的页面通信。</a><br><strong>目的：</strong> 向另一个地方传递数据，对于XDM而言，“另一个地方”指的是包含在当前页面中的<iframe>或者由当前页面弹出的窗口<br>postMessage方法接收两个参数，一条消息和一个表示消息接收方来自哪个域的字符串。第二个参数对保障安全通信非常重要，可以防止浏览器把消息发送到不安全的地方。来看下面的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iframeWindow = <span class="built_in">document</span>.getElementById(<span class="string">'myframe'</span>).contentWindow</span><br><span class="line">iframeWindow.postMessage(<span class="string">'A secret'</span>, <span class="string">'http://www.wrox.com'</span>)</span><br></pre></td></tr></table></figure></iframe></p>
<h2 id="原生拖放"><a href="#原生拖放" class="headerlink" title="原生拖放"></a>原生拖放</h2><p>1，按住鼠标不动拖放一些图片和选中的文字。<br>依次触发<br>dragstart  触发这个之后，随即触发drag事件<br>drag<br>dragend</p>
<p>2，当某个元素被拖动到一个有效的放置目标上，依次发生<br>dragenter<br>dragover<br>dragleave/drop</p>
<p>3，dataTransfer对象是拖放事件的属性，所以只能在拖放事件处理程序中访问它<br>dataTransfer对象有两个主要方法(在drop事件处理程序中)：getData()和setData()<br>//设置和接受文本数据<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">event.dataTransfer.setData(<span class="string">"text"</span>,<span class="string">"some text"</span>);</span><br><span class="line"><span class="keyword">var</span> text=event.dataTransfer.gatData(<span class="string">"Text"</span>);</span><br><span class="line"><span class="comment">//设置和接受URL</span></span><br><span class="line">event.dataTransfer.setData(<span class="string">"URL"</span>,<span class="string">"http://www.wrox.com/"</span>);</span><br><span class="line"><span class="keyword">var</span> text=event.dataTransfer.gatData(<span class="string">"url"</span>)||event.dataTransfer.gatData(<span class="string">"text/uri-list"</span>);</span><br></pre></td></tr></table></figure></p>
<p>4， dataTransfer对象不光可以传输数据，还能通过它来确定被拖动的元素以及作为放置目标的元素能够接受什么操作<br>dropEffect属性（在ondragenter事件处理程序中设置）可以知道被拖动的元素能够执行哪种放置行为：<br>“none”–不能把拖动的元素放在这里（这是除文本框之外所有元素的默认值）<br>“move”–应该把拖动的元素移动到放置目标<br>“copy”–应该把拖动的元素复制到放置目标<br>“link”–表示放置目标会打开拖动的元素（拖动的元素必须是一个链接，有URL）</p>
<p>5，<br>draggable属性表示元素是否可以拖动（默认情况下，图像、链接和文本是可以拖动的）<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"smile.gif"</span> <span class="attr">draggable</span>=<span class="string">"false"</span> <span class="attr">alt</span>=<span class="string">"Smiley face"</span>&gt;</span> //使图像不可拖动</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> //使这个元素可以拖动</span><br></pre></td></tr></table></figure></p>
<p>6，媒体元素<br><figure class="highlight plain"><figcaption><span>and <video>```</video></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7,历史状态管理</span><br><span class="line">解决用户难在不同状态之间切换的问题，这种切换不仅仅是整个页面，而是不同页面状态的切换用栈的思想</span><br><span class="line">当hashchange事件发生的时候，使用history.pushState()方法；</span><br><span class="line">history.pushState(状态对象，新状态的标题，可选的相对URL) //新的状态信息加入到历史状态栈，浏览器地址栏也会变成新的相对URL；</span><br><span class="line">点击“后退”按钮，会触发window对象的popstate事件，对应的事件对象有一个state属性，包含着当初以第一个参数传递给pushState()的状态对象</span><br><span class="line">更新当前状态，可以调用replaceState()，传入的参数与pushState()的前两个参数相同，会重写当前状态：</span><br><span class="line">history.replaceState(&#123;name:&quot;Greg&quot;&#125;,&quot;Greg&apos;s page&quot;);</span><br><span class="line"></span><br><span class="line"># 第二十章 JSON</span><br><span class="line">利用了javascript中的一下模式来结构化数据，但并不是只有js才能使用json.</span><br><span class="line">JSON可以用来表示 简单值，对象和数组。</span><br><span class="line">Json中的属性名必须加双引号  &quot;name&quot;:&quot;Nicholas&quot;</span><br><span class="line">## 解析和序列化很简单</span><br><span class="line">直接用books[2].title</span><br><span class="line"></span><br><span class="line">解析早期用eval();</span><br><span class="line"></span><br><span class="line">全局对象 JSON ，有两个方法：stringify() 和 parse ()。</span><br><span class="line">stringify 用于将 JavaScript 值类型（除undefined）或引用类型（对象和数组）转换为保存了 JSON 格式的 JavaScript 字符串。</span><br><span class="line">JSON格式就是一行字符串但是是json的框架，但是不包含任何字符或者缩进。</span><br><span class="line">parse 用于将保存了 JSON 格式的 JavaScript 字符串转换为 JavaScript 中的值类型或引用类型（对象和数组）。</span><br><span class="line"></span><br><span class="line">## Json.stringify()</span><br><span class="line">JSON.stringify()方法有三个参数:</span><br><span class="line">第一个参数是要序列化的JavaScript对象;</span><br><span class="line">第二个参数是过滤器,可以是一个数组或者函数;</span><br><span class="line">第三个参数是一个布尔值,表示是否在JSON字符串中保留缩进.</span><br><span class="line"></span><br><span class="line">如果缩进参数传入的是数值,表示每个json字段缩进的空格数,但是最大缩进空格数不超过10.</span><br><span class="line">```javascript</span><br><span class="line">var jsonText=JSON.stringify(book,null,4)</span><br></pre></td></tr></table></figure></p>
<p>如果缩进参数传入的是字符串,则表示JSON字符串中每个级别都使用该字符串作为缩进字符.不过该字符串也不能超过10个字符长.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonText=<span class="built_in">JSON</span>.stringify(book,<span class="literal">null</span>,<span class="string">"--"</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="tojson"><a href="#tojson" class="headerlink" title="tojson()"></a>tojson()</h2><p>toJSON()方法  <strong>就是按照自己格式自定义输出的function</strong><br>如果JSON.stringify()不能满足某些对象的序列化需求，可以给对象自定义toJSON方法，返回其自身的JSON数据格式。<br>综合以上几种情况，JSON.stringify()序列化对象的顺序如下：</p>
<p>①如果对象存在toJSON方法且能返回有效值，则调用该方法；否则，仍然按照默认顺序执行序列化。<br>②如果stringify()存在第二个参数，应用这个过滤器；<br>③对第②步返回的每个值进行序列化；<br>④如果存在第三个参数，执行相应的格式化。</p>
<h2 id="parse"><a href="#parse" class="headerlink" title="parse()"></a>parse()</h2><p>JSON.parse()用来将JSON字符串解析成JavaScript对象。</p>
<p>该方法第一个参数要解析的JSON字符串；</p>
<p>第二个参数是一个函数还原函数。还原函数有两个参数key和value。如果还原函数返回undefined，则表示将该属性从结果中删除；如果返回其它值，则将该值插入到结果当中。在将日期字符串转换为Date对象时，经常用到还原函数.</p>
<p>有些比如date格式的东西， 不好直接parse，要弄个function来parse</p>
<h1 id="第21章-Ajax与Comet"><a href="#第21章-Ajax与Comet" class="headerlink" title="第21章  Ajax与Comet"></a>第21章  Ajax与Comet</h1><p>转自 <a href="http://jiaochunxiao.github.io/2016/12/04/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0-15/" target="_blank" rel="noopener">http://jiaochunxiao.github.io/2016/12/04/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0-15/</a><br>Ajax(Asynchronous Javascript + XML)技术的核心是XMLHttpRequest对象,即: XHR。虽然名字中包含XML，但它所指的仅仅是这种无须刷新页面即可从服务器端获取数据的技术，其通信与数据格式无关，并不一定是XML数据。</p>
<p>XMLHttpRequest对象<br>IE7+、Firefox、Opera、Chrome 和 Safari 都支持原生的XHR对象。我们可以直接使用XMLHttpRequest构造函数来创建XHR对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure></p>
<p>虽然，IE7之前版本的浏览器中，创建xhr的方法与此有所不同，但是，前端技术发展到今天，已经很少有业务需求是要支持IE7之前的版本了。因此，这里我略过这一情况。<br>XHR的用法<br>使用 XHR对象的时候，要调用的第一个方法是open()，它接受3个参数:<br>要发送请求的类型，如: get/post<br>请求的url<br>是否异步发送请求，这个参数是一个布尔值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'example.php'</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p>
<p>注意：open()方法的调用并不会真正发送请求，仅仅是启动一个请求以备发送!<br>另外，只能向同一个域中使用相同端口和协议的URL发送请求，否则，会出现错误。<br>在执行open()方法之后，必须再调用send()方法，才会真正发起ajax请求。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'example.txt'</span>, <span class="literal">false</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>send()方法接收一个参数，即：要作为请求主体发送的数据。如果不需要发送数据，那么必须传入null，因为该参数对于部分浏览器而言是必需的。<br>本例中的请求是同步的，Javascript代码会等到服务器响应之后再执行。 收到响应后，响应的数据会自动填充XHR对象的属性，相关的属性有:<br><strong>responseText: 作为响应主体被返回的文本。</strong><br>responseXML: 如果响应的内容类型是”text/xml”或者”application/xml”，那么这个属性中将保存着包含响应数据的XML DOM文档。<br><strong>status: 响应的HTTP状态</strong><br><strong>statusText: HTTP状态的说明</strong><br>无论内容类型是什么，响应主体的内容都会保存到responseText属性中，而对于非XML数据而言，responseXML 属性的值将会是null。</p>
<p>收到响应后，一般来说，会先判断 status 是否为200，这是此次请求成功的标志。此时，responseText属性的内容已经就绪，而且在内容类型正确的情况下，responseXML也能够访问了。 另外，状态码status如果是304，那么表示请求的资源没有被修改，可以直接使用浏览器中的缓存，当然，这样的响应也是有效的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span> )&#123;</span><br><span class="line">	alert(xhr.responseText);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	alert(<span class="string">'fail! status:'</span> + xhr.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有的浏览器会错误地报告 204 的状态代码。IE中 XHR 的ActiveX版本会将204设置为1223，而IE中原生的 XHR 则会将 204 规范化为 200。Opera会在取得204时报告 status的值为0。</p>
<p>检测XHR对象的readyState属性，该属性表示请求/响应过程的当前活动阶段。属性可取值如下：</p>
<p>0：未初始化，尚未调用open()方法<br>1：启动，已经调用open()方法，但尚未调用send()方法<br>2：发送，已经调用send()方法，但尚未接到响应<br>3：接收，已经接收到部分数据<br>4：完成，已经接收到全部响应数据，而且已经可以在客户端使用了。<br>只要readyState属性的值由一个值变成另一个值，都会触发一次readystatechange事件。必须在调用open()方法之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性。</p>
<p>在接收到响应之前可以调用abort()方法来取消异步请求。</p>
<p>通过setRequestHeader()方法可以设置自定义的头部信息。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">"MyHeader"</span>. <span class="string">"Myvalue"</span>);</span><br></pre></td></tr></table></figure></p>
<p>Get请求<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"example.php?name1 = value1&amp;name2=value2"</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>Post请求<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"post"</span>, <span class="string">"example"</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>可以使用XHR来模仿表单提交：将Content-Type头部信息设置为application/x-www-form-urlencoded，也就是表单提交时的内容类型，其次是以适当的格式创建一个字符串（第14章介绍的serialize()函数）。<br>FormData类型用于便捷地将表单数据序列化。</p>
<p>超时设定用timeout属性</p>
<p>progress事件常用于创建进度指示器。</p>
<h2 id="Cors"><a href="#Cors" class="headerlink" title="Cors"></a>Cors</h2><p>CORS（跨域资源共享）定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。</p>
<pre><code>IE对CORS实现-XDR（XDomainRequest)
cookie不会随请求发送，也不会随响应返回
只能设置请求头部信息中的Content-Type字段
不能访问响应头部信息
只支持 GET和POST请求
所有的XDR请求都是异步的，不能用来创建同步请求。
</code></pre><p>其他浏览器原生就支持CORS</p>
<h2 id="其他跨域技术"><a href="#其他跨域技术" class="headerlink" title="其他跨域技术"></a>其他跨域技术</h2><h3 id="图片Ping"><a href="#图片Ping" class="headerlink" title="图片Ping"></a>图片Ping</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.onload = img.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"Done!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">img.src=<span class="string">'http://www.example.com/test?name="test"'</span>;</span><br></pre></td></tr></table></figure>
<p>缺点：<br>只能发送get 请求<br>无法访问服务的响应文本</p>
<h3 id="JSONP（JSON-with-padding，填充式JSON或参数式JSON）"><a href="#JSONP（JSON-with-padding，填充式JSON或参数式JSON）" class="headerlink" title="JSONP（JSON with padding，填充式JSON或参数式JSON）"></a>JSONP（JSON with padding，填充式JSON或参数式JSON）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"You're at IP address "</span> + response.ip);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.src=<span class="string">'http://freegeoip.net/json/?callback=handleResponse'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body,firstChild);</span><br></pre></td></tr></table></figure>
<p>优点：能够直接访问响应文本，支持在浏览器与服务器之间双向通信。<br>缺点：<br>JSONP是从其他域中加载代码执行，如果其他域不安全，很可能会在响应中夹带一些恶意代码<br>要确定JSONP请求是否失败并不容易</p>
<h3 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h3><p>Ajax是一种从页面向服务器请求数据的技术，而Comet则是一种服务器向页面推送数据的技术。两种实现Comet的方法：长轮询和流。<br>短轮询：浏览器定时向着服务器发送请求，看有没有更新的数据。<br>长轮询：页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可发送，发送完数据之后，浏览器关闭连接，随机又发起一个到服务器的新请求。</p>
<p>流： 它在整个http生命周期只有一个http连接，具体来说就是浏览器向服务器发送一个请求，服务器一直保持打开，然后周期性地向浏览器发送数据。</p>
<h2 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h2><h3 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h3><h3 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h3><p>是一种与服务器进行全双工，双向通信的信道。<br>不使用http，是一种自定义的协议。</p>
<p>要创建Web Socket，先实例一个WebSocket对象并传入要连接的URL：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://www.example.com/server.php"</span>);</span><br></pre></td></tr></table></figure></p>
<p>注意，必须给WebSocket构造函数传入绝对URL。同源策略对Web Socket不实用，因此可以通过它打开任何站点的连接。至于是否会与某个域中的页面通信，则完全取决于服务器。</p>
<h1 id="第22章"><a href="#第22章" class="headerlink" title="第22章"></a>第22章</h1><h2 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h2><p>一般工作闭包实现</p>
<h3 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h3><p>每次做检测都有大量if else很消耗事件，我们先把结果返回进 一个function（之后会覆盖）就好了。</p>
<h3 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h3><p>可以在特定的this环境中以指定参数调用另一个函数<br>bind()函数接受一个函数和环境</p>
<h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>他就是方便在任何情况下用一个参数或者多个参数做function<br>比如 curry(add,3）curriedAdd(3) //8</p>
<p>原理：使用闭包<br>可以一个个参数给进去。</p>
<h2 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h2><p>JavaScript 是运行在单线程环境中的。<br>setTimeout() 和setInterval() 其实不是马上执行，而是把任务放进一个队列里。<br>当使用setInterval()，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。</p>
<h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><p> 背景：浏览器中某些计算和处理比其他的昂贵很多，例如DOM操作，消耗更多的内存和CPU时间<br>基本思想：某些代码不可以在没有间断的情况连续重复执行<br>实现：定时器<br>应用：只要代码是周期性执行，都应该使用节流，但是你不能控制请求执行的频率。<br>中心思想就比如resize每一瞬间都要调用一些事件，你现在用定时器，让它控制在每100ms<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">method, scope</span>) </span>&#123;</span><br><span class="line">            clearTimeout(method.tId);<span class="comment">//清除之前的id，重新开始</span></span><br><span class="line">            method.tId= setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                method.call(scope);  <span class="comment">//没有传入scope时，那么就在全局作用域内执行该方法</span></span><br><span class="line">            &#125;, <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>应用观察者模式，使用自定义事件有助于将不同部分代码相互之间解耦，让维护更加容易，减少引入错误的机会。</p>
<h2 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h2><h1 id="第23章-离线应用与客户端存储"><a href="#第23章-离线应用与客户端存储" class="headerlink" title="第23章 离线应用与客户端存储"></a>第23章 离线应用与客户端存储</h1><h2 id="离线检测"><a href="#离线检测" class="headerlink" title="离线检测"></a>离线检测</h2><p>使用navigator.online属性判断是否离线与否</p>
<h2 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h2><p>HTML5应用缓存，简称appcache</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>在客户端存储会话信息的，该标准要求服务器对任意http请求发送set-cookie http头作为响应的一部分。<br>cookie浏览器中一般4mb，键值对，有失效时间。所有名字和值都通过URL编码，必须使用decodeURIComponent()来解码。</p>
<p>在javascript中通过document.cookie可以访问cookie。</p>
<h3 id="子cookie"><a href="#子cookie" class="headerlink" title="子cookie"></a>子cookie</h3><p>就是把很多cookie放在一条cookie里面，节省空间。<br>获取子cookie方法两个，get()和getall();<br>尽可能在cookie中少存储信息，避免影响性能。</p>
<h3 id="IE用户数据"><a href="#IE用户数据" class="headerlink" title="IE用户数据"></a>IE用户数据</h3><p>userdata</p>
<h2 id="web存储机制"><a href="#web存储机制" class="headerlink" title="web存储机制"></a>web存储机制</h2><p>当数据需要被严格控制在客户端上，无需持续地将数据发回给服务器。就需要sessionStorage和globalStorage出马了。他们是存储大量可以跨会话存在的数据的机制。</p>
<h3 id="sessionstorage对象"><a href="#sessionstorage对象" class="headerlink" title="sessionstorage对象"></a>sessionstorage对象</h3><p>sessionStorage对象存储特定于某个会话的数据。也就是该数据只保存到浏览器关闭。<br>主要应用于仅针对会话的小段数据的存储，跨越会话用globalstorage更好。</p>
<h3 id="globalStorage"><a href="#globalStorage" class="headerlink" title="globalStorage"></a>globalStorage</h3><p>跨越会话存储数据，有特定的访问限制。<br><strong>要使用的话，首先要指定哪些域可以访问该数据。</strong></p>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p><strong>不能给它指定任何访问规则，因为已经实现设定好了。 要访问同一个localStorage对象， 页面必须来自同一个域名，使用同一种协议，在同一个端口上。</strong><br>一般大小给5mb</p>
<h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>是在浏览器中保存结构化数据的一种数据库，indexedDB设计的操作完全是异步进行的。<br>最大特色是使用对象保存数据，而不是使用表来保存数据。<br>首先要indexDB.open()打开</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/frontend/" rel="tag"># frontend</a>
          
            <a href="/tags/book-notes/" rel="tag"># book notes</a>
          
            <a href="/tags/javascript/" rel="tag"># javascript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/02/《图解HTTP》读书笔记/" rel="next" title="《图解HTTP》读书笔记">
                <i class="fa fa-chevron-left"></i> 《图解HTTP》读书笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/06/通过剑指第二十题学习javascript正则表达式/" rel="prev" title="通过剑指第二十题学习javascript正则表达式">
                通过剑指第二十题学习javascript正则表达式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Kailiang Dong">
            
              <p class="site-author-name" itemprop="name">Kailiang Dong</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Kailiangdong" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:kailiang.dong@tum.de" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/kailiang.dong.9" target="_blank" title="FB Page">
                      
                        <i class="fa fa-fw fa-facebook"></i>FB Page</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一章-JavaScript简介"><span class="nav-number">1.</span> <span class="nav-text">第一章 JavaScript简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章-JavaScript运用在html中"><span class="nav-number">2.</span> <span class="nav-text">第二章 JavaScript运用在html中</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三章-基本概念"><span class="nav-number">3.</span> <span class="nav-text">第三章 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型"><span class="nav-number">3.1.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.1.1.</span> <span class="nav-text">undefined</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Boolean"><span class="nav-number">3.2.</span> <span class="nav-text">Boolean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Number"><span class="nav-number">3.3.</span> <span class="nav-text">Number</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数值转换"><span class="nav-number">3.3.1.</span> <span class="nav-text">数值转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Number-1"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">Number()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#parseInt"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">parseInt()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#parseFloat"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">parseFloat()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String"><span class="nav-number">3.4.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object"><span class="nav-number">3.5.</span> <span class="nav-text">Object</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作符"><span class="nav-number">3.6.</span> <span class="nav-text">操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#位操作符"><span class="nav-number">3.6.1.</span> <span class="nav-text">位操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#布尔操作符"><span class="nav-number">3.6.2.</span> <span class="nav-text">布尔操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#乘性操作符"><span class="nav-number">3.6.3.</span> <span class="nav-text">乘性操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加性操作符"><span class="nav-number">3.6.4.</span> <span class="nav-text">加性操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#减性操作符"><span class="nav-number">3.6.5.</span> <span class="nav-text">减性操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系操作符"><span class="nav-number">3.6.6.</span> <span class="nav-text">关系操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for语句"><span class="nav-number">3.6.7.</span> <span class="nav-text">for语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-in语句"><span class="nav-number">3.6.8.</span> <span class="nav-text">for-in语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#break和continue"><span class="nav-number">3.6.9.</span> <span class="nav-text">break和continue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#label-看p59页"><span class="nav-number">3.6.10.</span> <span class="nav-text">label 看p59页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#with语句-不太用了"><span class="nav-number">3.6.11.</span> <span class="nav-text">with语句 不太用了</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">3.7.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#没有重载d"><span class="nav-number">3.7.1.</span> <span class="nav-text">没有重载d</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变量，作用域和内存问题"><span class="nav-number">4.</span> <span class="nav-text">变量，作用域和内存问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#延长作用域链"><span class="nav-number">4.1.</span> <span class="nav-text">延长作用域链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#没有块级作用域"><span class="nav-number">4.2.</span> <span class="nav-text">没有块级作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集"><span class="nav-number">4.3.</span> <span class="nav-text">垃圾收集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标记清楚"><span class="nav-number">4.3.1.</span> <span class="nav-text">标记清楚</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数"><span class="nav-number">4.3.2.</span> <span class="nav-text">引用计数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五章"><span class="nav-number">5.</span> <span class="nav-text">第五章</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#object"><span class="nav-number">5.1.</span> <span class="nav-text">object</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#array"><span class="nav-number">5.2.</span> <span class="nav-text">array</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#检测数组"><span class="nav-number">5.2.1.</span> <span class="nav-text">检测数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转换方法"><span class="nav-number">5.2.2.</span> <span class="nav-text">转换方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈方法与队列方法"><span class="nav-number">5.2.3.</span> <span class="nav-text">栈方法与队列方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重排序方法"><span class="nav-number">5.2.4.</span> <span class="nav-text">重排序方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作方法"><span class="nav-number">5.2.5.</span> <span class="nav-text">操作方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位置方法"><span class="nav-number">5.2.6.</span> <span class="nav-text">位置方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代方法"><span class="nav-number">5.2.7.</span> <span class="nav-text">迭代方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Date"><span class="nav-number">5.3.</span> <span class="nav-text">Date</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承的方法"><span class="nav-number">5.3.1.</span> <span class="nav-text">继承的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RegExp类型"><span class="nav-number">5.4.</span> <span class="nav-text">RegExp类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RegExp实例属性"><span class="nav-number">5.4.1.</span> <span class="nav-text">RegExp实例属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例方法"><span class="nav-number">5.4.2.</span> <span class="nav-text">实例方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RegExp构造函数属性"><span class="nav-number">5.4.3.</span> <span class="nav-text">RegExp构造函数属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Function"><span class="nav-number">5.5.</span> <span class="nav-text">Function</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数声明与函数表达式"><span class="nav-number">5.5.1.</span> <span class="nav-text">函数声明与函数表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作为值的函数"><span class="nav-number">5.5.2.</span> <span class="nav-text">作为值的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数内部属性"><span class="nav-number">5.5.3.</span> <span class="nav-text">函数内部属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apply-和call"><span class="nav-number">5.5.4.</span> <span class="nav-text">apply()和call()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bind"><span class="nav-number">5.5.5.</span> <span class="nav-text">bind()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本包装类型"><span class="nav-number">5.5.6.</span> <span class="nav-text">基本包装类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#number类型"><span class="nav-number">5.5.6.1.</span> <span class="nav-text">number类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String类型"><span class="nav-number">5.5.7.</span> <span class="nav-text">String类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串拼接"><span class="nav-number">5.5.7.1.</span> <span class="nav-text">字符串拼接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Global对象"><span class="nav-number">5.5.8.</span> <span class="nav-text">Global对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math-对象"><span class="nav-number">5.5.9.</span> <span class="nav-text">Math 对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六章-面向对象的程序设计"><span class="nav-number">6.</span> <span class="nav-text">第六章 面向对象的程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#理解对象"><span class="nav-number">6.1.</span> <span class="nav-text">理解对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#属性类型"><span class="nav-number">6.1.1.</span> <span class="nav-text">属性类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问器属性"><span class="nav-number">6.1.2.</span> <span class="nav-text">访问器属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读取属性的特性"><span class="nav-number">6.1.3.</span> <span class="nav-text">读取属性的特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建对象"><span class="nav-number">6.2.</span> <span class="nav-text">创建对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂模式"><span class="nav-number">6.2.1.</span> <span class="nav-text">工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数模式"><span class="nav-number">6.2.2.</span> <span class="nav-text">构造函数模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将构造函数当作函数"><span class="nav-number">6.2.2.1.</span> <span class="nav-text">将构造函数当作函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型模式"><span class="nav-number">6.3.</span> <span class="nav-text">原型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解原型对象"><span class="nav-number">6.3.1.</span> <span class="nav-text">理解原型对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型与in操作符"><span class="nav-number">6.3.2.</span> <span class="nav-text">原型与in操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更简单的语法，每次用prototype你烦不烦"><span class="nav-number">6.3.3.</span> <span class="nav-text">更简单的语法，每次用prototype你烦不烦</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型的动态性"><span class="nav-number">6.3.4.</span> <span class="nav-text">原型的动态性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原生对象的原型"><span class="nav-number">6.3.5.</span> <span class="nav-text">原生对象的原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型的问题"><span class="nav-number">6.3.6.</span> <span class="nav-text">原型的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合使用构造函数模式与原型模式"><span class="nav-number">6.4.</span> <span class="nav-text">组合使用构造函数模式与原型模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态原型模式"><span class="nav-number">6.5.</span> <span class="nav-text">动态原型模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#寄生构造函数模式"><span class="nav-number">6.6.</span> <span class="nav-text">寄生构造函数模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#稳妥构造函数模式"><span class="nav-number">6.7.</span> <span class="nav-text">稳妥构造函数模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">6.8.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原型链"><span class="nav-number">6.8.1.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#确定原型和实例的关系"><span class="nav-number">6.8.2.</span> <span class="nav-text">确定原型和实例的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#谨慎地定义方法"><span class="nav-number">6.8.3.</span> <span class="nav-text">谨慎地定义方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型链的问题"><span class="nav-number">6.8.4.</span> <span class="nav-text">原型链的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#借用构造函数"><span class="nav-number">6.9.</span> <span class="nav-text">借用构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合继承"><span class="nav-number">6.10.</span> <span class="nav-text">组合继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型式继承"><span class="nav-number">6.11.</span> <span class="nav-text">原型式继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#问题"><span class="nav-number">6.11.1.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寄生式继承"><span class="nav-number">6.11.2.</span> <span class="nav-text">寄生式继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寄生组合式继承"><span class="nav-number">6.11.3.</span> <span class="nav-text">寄生组合式继承</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七章-函数表达式"><span class="nav-number">7.</span> <span class="nav-text">第七章 函数表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#递归"><span class="nav-number">7.1.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包"><span class="nav-number">7.2.</span> <span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包作用链细节"><span class="nav-number">7.2.1.</span> <span class="nav-text">闭包作用链细节:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包缺点"><span class="nav-number">7.2.2.</span> <span class="nav-text">闭包缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于this对象"><span class="nav-number">7.2.3.</span> <span class="nav-text">关于this对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模仿块级作用域"><span class="nav-number">7.2.4.</span> <span class="nav-text">模仿块级作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#私有变量"><span class="nav-number">7.2.5.</span> <span class="nav-text">私有变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数法"><span class="nav-number">7.2.5.1.</span> <span class="nav-text">构造函数法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态私有变量"><span class="nav-number">7.2.5.2.</span> <span class="nav-text">静态私有变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块模式"><span class="nav-number">7.2.6.</span> <span class="nav-text">模块模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第八章"><span class="nav-number">8.</span> <span class="nav-text">第八章</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#窗口关系及框架"><span class="nav-number">8.1.</span> <span class="nav-text">窗口关系及框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#窗口位置"><span class="nav-number">8.2.</span> <span class="nav-text">窗口位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#窗口大小"><span class="nav-number">8.3.</span> <span class="nav-text">窗口大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#导航和打开窗口"><span class="nav-number">8.4.</span> <span class="nav-text">导航和打开窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安全性屏蔽"><span class="nav-number">8.5.</span> <span class="nav-text">安全性屏蔽</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#间歇调用和超时调用"><span class="nav-number">8.6.</span> <span class="nav-text">间歇调用和超时调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统对话框"><span class="nav-number">8.7.</span> <span class="nav-text">系统对话框</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#location-对象"><span class="nav-number">8.8.</span> <span class="nav-text">location 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查询字符串参数"><span class="nav-number">8.8.1.</span> <span class="nav-text">查询字符串参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位置操作-location"><span class="nav-number">8.8.2.</span> <span class="nav-text">位置操作 location</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Navigator"><span class="nav-number">8.9.</span> <span class="nav-text">Navigator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注册处理程序"><span class="nav-number">8.9.1.</span> <span class="nav-text">注册处理程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#history"><span class="nav-number">8.10.</span> <span class="nav-text">history</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结一下"><span class="nav-number">8.11.</span> <span class="nav-text">总结一下</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第九章-客户端检测"><span class="nav-number">9.</span> <span class="nav-text">第九章 客户端检测</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#能力检测"><span class="nav-number">9.1.</span> <span class="nav-text">能力检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更好的能力检测"><span class="nav-number">9.2.</span> <span class="nav-text">更好的能力检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器检测"><span class="nav-number">9.3.</span> <span class="nav-text">浏览器检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怪癖检测"><span class="nav-number">9.4.</span> <span class="nav-text">怪癖检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户代理检测"><span class="nav-number">9.5.</span> <span class="nav-text">用户代理检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测技术"><span class="nav-number">9.6.</span> <span class="nav-text">检测技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">9.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DOM"><span class="nav-number">10.</span> <span class="nav-text">DOM</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十一章-DOM扩展"><span class="nav-number">11.</span> <span class="nav-text">第十一章 DOM扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#html5"><span class="nav-number">11.1.</span> <span class="nav-text">html5</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#getElementsByClassName-方法"><span class="nav-number">11.1.1.</span> <span class="nav-text">getElementsByClassName()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#classlist属性"><span class="nav-number">11.1.2.</span> <span class="nav-text">classlist属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#焦点管理"><span class="nav-number">11.1.3.</span> <span class="nav-text">焦点管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTMLDocument的变化"><span class="nav-number">11.2.</span> <span class="nav-text">HTMLDocument的变化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#innerHTML"><span class="nav-number">11.2.1.</span> <span class="nav-text">innerHTML</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#outerHTML"><span class="nav-number">11.2.2.</span> <span class="nav-text">outerHTML</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#insertAdjacentHTML-方法"><span class="nav-number">11.2.3.</span> <span class="nav-text">insertAdjacentHTML()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用以上方法的一些问题"><span class="nav-number">11.2.4.</span> <span class="nav-text">用以上方法的一些问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scrollIntoView"><span class="nav-number">11.2.5.</span> <span class="nav-text">scrollIntoView</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他拓展功能"><span class="nav-number">11.3.</span> <span class="nav-text">其他拓展功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文档模式"><span class="nav-number">11.3.1.</span> <span class="nav-text">文档模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#children属性"><span class="nav-number">11.3.2.</span> <span class="nav-text">children属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#contains-方法"><span class="nav-number">11.3.3.</span> <span class="nav-text">contains()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入文本"><span class="nav-number">11.3.4.</span> <span class="nav-text">插入文本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十二章-DOM2和DOM3"><span class="nav-number">12.</span> <span class="nav-text">第十二章 DOM2和DOM3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十三章-事件"><span class="nav-number">13.</span> <span class="nav-text">第十三章 事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#事件流"><span class="nav-number">13.1.</span> <span class="nav-text">事件流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事件冒泡"><span class="nav-number">13.1.1.</span> <span class="nav-text">事件冒泡</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件冒泡-1"><span class="nav-number">13.2.</span> <span class="nav-text">事件冒泡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dom事件流"><span class="nav-number">13.3.</span> <span class="nav-text">dom事件流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件处理程序"><span class="nav-number">13.4.</span> <span class="nav-text">事件处理程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTML事件处理程序"><span class="nav-number">13.5.</span> <span class="nav-text">HTML事件处理程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM0"><span class="nav-number">13.6.</span> <span class="nav-text">DOM0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM2事件处理程序"><span class="nav-number">13.7.</span> <span class="nav-text">DOM2事件处理程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IE事件处理"><span class="nav-number">13.8.</span> <span class="nav-text">IE事件处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跨浏览器处理"><span class="nav-number">13.9.</span> <span class="nav-text">跨浏览器处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件对象"><span class="nav-number">13.10.</span> <span class="nav-text">事件对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ie事件对象"><span class="nav-number">13.10.1.</span> <span class="nav-text">ie事件对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跨浏览器事件对象"><span class="nav-number">13.10.2.</span> <span class="nav-text">跨浏览器事件对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件类型"><span class="nav-number">13.11.</span> <span class="nav-text">事件类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UI事件：不一定与用户操作有关的事件"><span class="nav-number">13.11.1.</span> <span class="nav-text">UI事件：不一定与用户操作有关的事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#焦点事件"><span class="nav-number">13.11.2.</span> <span class="nav-text">焦点事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#鼠标与滚轮事件"><span class="nav-number">13.11.3.</span> <span class="nav-text">鼠标与滚轮事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#键盘与文本事件"><span class="nav-number">13.11.4.</span> <span class="nav-text">键盘与文本事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复合事件"><span class="nav-number">13.11.5.</span> <span class="nav-text">复合事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变动事件"><span class="nav-number">13.11.6.</span> <span class="nav-text">变动事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML5-事件"><span class="nav-number">13.11.7.</span> <span class="nav-text">HTML5 事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设备事件"><span class="nav-number">13.11.8.</span> <span class="nav-text">设备事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#触摸与手势事件"><span class="nav-number">13.11.9.</span> <span class="nav-text">触摸与手势事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#键盘-与文本事件"><span class="nav-number">13.12.</span> <span class="nav-text">键盘 与文本事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存和性能"><span class="nav-number">13.13.</span> <span class="nav-text">内存和性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事件委托"><span class="nav-number">13.13.1.</span> <span class="nav-text">事件委托</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#移除事件处理程序"><span class="nav-number">13.14.</span> <span class="nav-text">移除事件处理程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模拟事件"><span class="nav-number">13.15.</span> <span class="nav-text">模拟事件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#表单脚本"><span class="nav-number">14.</span> <span class="nav-text">表单脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#提交表单"><span class="nav-number">14.1.</span> <span class="nav-text">提交表单</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重置表单"><span class="nav-number">14.2.</span> <span class="nav-text">重置表单</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表单字段"><span class="nav-number">14.3.</span> <span class="nav-text">表单字段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#共有表单字段方法"><span class="nav-number">14.3.1.</span> <span class="nav-text">共有表单字段方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文本框脚本"><span class="nav-number">14.4.</span> <span class="nav-text">文本框脚本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择脚本"><span class="nav-number">14.5.</span> <span class="nav-text">选择脚本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过滤输出"><span class="nav-number">14.6.</span> <span class="nav-text">过滤输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作剪贴板"><span class="nav-number">14.7.</span> <span class="nav-text">操作剪贴板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动切换焦点"><span class="nav-number">14.8.</span> <span class="nav-text">自动切换焦点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#html5新增表单功能"><span class="nav-number">14.9.</span> <span class="nav-text">html5新增表单功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择框脚本"><span class="nav-number">14.10.</span> <span class="nav-text">选择框脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#选择选项"><span class="nav-number">14.10.1.</span> <span class="nav-text">选择选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加选项"><span class="nav-number">14.10.2.</span> <span class="nav-text">添加选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移除选项"><span class="nav-number">14.10.3.</span> <span class="nav-text">移除选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移动和重排选项"><span class="nav-number">14.10.4.</span> <span class="nav-text">移动和重排选项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表单序列化"><span class="nav-number">14.11.</span> <span class="nav-text">表单序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#富文本编辑"><span class="nav-number">14.12.</span> <span class="nav-text">富文本编辑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用创建富文本编辑区域"><span class="nav-number">14.12.1.</span> <span class="nav-text">使用创建富文本编辑区域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用contenteditable属性"><span class="nav-number">14.12.2.</span> <span class="nav-text">使用contenteditable属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作富文本"><span class="nav-number">14.12.3.</span> <span class="nav-text">操作富文本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#富文本选区"><span class="nav-number">14.12.4.</span> <span class="nav-text">富文本选区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#表单与富文本"><span class="nav-number">14.12.5.</span> <span class="nav-text">表单与富文本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第16章-HTML5脚本编程"><span class="nav-number">15.</span> <span class="nav-text">第16章 HTML5脚本编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#跨文档消息传递"><span class="nav-number">15.1.</span> <span class="nav-text">跨文档消息传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原生拖放"><span class="nav-number">15.2.</span> <span class="nav-text">原生拖放</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tojson"><span class="nav-number">15.3.</span> <span class="nav-text">tojson()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#parse"><span class="nav-number">15.4.</span> <span class="nav-text">parse()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第21章-Ajax与Comet"><span class="nav-number">16.</span> <span class="nav-text">第21章  Ajax与Comet</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Cors"><span class="nav-number">16.1.</span> <span class="nav-text">Cors</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他跨域技术"><span class="nav-number">16.2.</span> <span class="nav-text">其他跨域技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图片Ping"><span class="nav-number">16.2.1.</span> <span class="nav-text">图片Ping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSONP（JSON-with-padding，填充式JSON或参数式JSON）"><span class="nav-number">16.2.2.</span> <span class="nav-text">JSONP（JSON with padding，填充式JSON或参数式JSON）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Comet"><span class="nav-number">16.2.3.</span> <span class="nav-text">Comet</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务器发送事件"><span class="nav-number">16.3.</span> <span class="nav-text">服务器发送事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SSE"><span class="nav-number">16.3.1.</span> <span class="nav-text">SSE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web-Sockets"><span class="nav-number">16.3.2.</span> <span class="nav-text">Web Sockets</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第22章"><span class="nav-number">17.</span> <span class="nav-text">第22章</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#高级函数"><span class="nav-number">17.1.</span> <span class="nav-text">高级函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#惰性载入函数"><span class="nav-number">17.1.1.</span> <span class="nav-text">惰性载入函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数绑定"><span class="nav-number">17.1.2.</span> <span class="nav-text">函数绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数柯里化"><span class="nav-number">17.1.3.</span> <span class="nav-text">函数柯里化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级定时器"><span class="nav-number">17.2.</span> <span class="nav-text">高级定时器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数节流"><span class="nav-number">17.3.</span> <span class="nav-text">函数节流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义事件"><span class="nav-number">17.4.</span> <span class="nav-text">自定义事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拖放"><span class="nav-number">17.5.</span> <span class="nav-text">拖放</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第23章-离线应用与客户端存储"><span class="nav-number">18.</span> <span class="nav-text">第23章 离线应用与客户端存储</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#离线检测"><span class="nav-number">18.1.</span> <span class="nav-text">离线检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用缓存"><span class="nav-number">18.2.</span> <span class="nav-text">应用缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cookie"><span class="nav-number">18.3.</span> <span class="nav-text">Cookie</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#子cookie"><span class="nav-number">18.3.1.</span> <span class="nav-text">子cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IE用户数据"><span class="nav-number">18.3.2.</span> <span class="nav-text">IE用户数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#web存储机制"><span class="nav-number">18.4.</span> <span class="nav-text">web存储机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sessionstorage对象"><span class="nav-number">18.4.1.</span> <span class="nav-text">sessionstorage对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#globalStorage"><span class="nav-number">18.4.2.</span> <span class="nav-text">globalStorage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#localStorage"><span class="nav-number">18.4.3.</span> <span class="nav-text">localStorage</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IndexedDB"><span class="nav-number">18.5.</span> <span class="nav-text">IndexedDB</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kailiang Dong</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
